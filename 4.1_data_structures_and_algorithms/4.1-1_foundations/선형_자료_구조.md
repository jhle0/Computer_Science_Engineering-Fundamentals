# 선형 자료 구조

---

### 고정 배열(Array)의 한계

- 배열은 보통 **연속된 메모리**에 저장되며, 생성 시 **크기(capacity)가 고정**되는 경우가 많다
- 크기를 초과하면 더 넣을 수 없거나(고정 배열), 더 큰 공간으로 **재할당**이 필요하다

---

## 동적 배열(dynamic array)

- 데이터 개수가 변할 때도 쓰기 편하게, 내부적으로 **용량(capacity)을 자동으로 늘려**주는 배열이다

### 특징(기본 배열 특성 포함)

- 원소가 **연속된 메모리**에 저장됨
- **인덱스 접근/변경**: O(1)
- **순회**가 빠름(캐시 친화적)

### 중요한 추가 특성

- **끝 삽입/삭제** `push_back/pop_back`: **상환 O(1)**
    - 용량이 부족해지면 더 큰 배열을 새로 만들고 복사하는 **재할당(reallocation)** 이 발생하여, 그 순간은 **O(n)** 이 될 수 있음
- **중간/앞 삽입·삭제**: **O(n)**
    - 뒤 원소들을 밀어야 함

### 구현

대부분의 언어들은 동적 배열을 **표준 라이브러리**에서 제공

- C++: `vector`
- JAVA: `Array list`
- C#: `List<T>`

---

## 연결 리스트(linked list)

배열에서는 원소들을 **임의의 위치에 삽입하거나, 삭제**하는 연산이 오래 걸린다는 문제를 해결 하기 위해 고안된 자료 구조 

### 연결 리스트 성능

- 특정 위치에서 삽입, 삭제를 상수 시간 - **O(1)**
- i 번째 노드를 찾는 행위는 선형 시간 - **O(N)**

### 구현

- 노드(node) 단위로 메모리 여기저기에 흩어져 있고,
- 각 노드는 다음/이전 노드를 가리키는 포인터를 가진다(단일/이중 연결 리스트)
- 포인터 때문에 **메모리 오버헤드**가 있고, 캐시 효율이 나빠 순회가 느릴 수 있다

→ 동적 배열과 같이, 대부분의 프로그래밍 언어에서 **표준 라이브러리**에서 제공된다

- C++ : `list`
- JAVA : `LinkedList`
- C#: `LinkedList<T>`

---

## 동적 배열과 연결 리스트 비교

둘의 가장 큰 차이점은 **삽입과 삭제** 그리고 **임의의 원소에 접근**하는 데 드는 시간

삽입과 삭제를 할 일이 없거나, 배열의 끝에서만 하면 될 경우에는 → **동적 배열**이 거의 항상 좋다

모든 원소들을 순회하며 삽입, 삭제를 한다면 → **연결리스트**가 좋은 선택
