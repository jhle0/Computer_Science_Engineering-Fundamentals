# 시간 복잡도와 Big-O 표기법

## 1) 시간 복잡도(Time Complexity)

### 정의

- **입력 크기 n에 따라 알고리즘 실행 시간이 어떻게 증가하는지**를 나타내는 척도이다.
- 실제 “초(seconds)”는 하드웨어/언어/환경에 따라 달라지므로, 보통 **연산 횟수(반복문, 재귀 호출 수 등)** 로 분석한다.

### 자주 등장하는 복잡도 예시

- **O(1) (상수 시간)**
    - 입력 크기와 무관하게 일정한 시간
    - 예: 배열 인덱스 접근, 단순 사칙연산, 비교/대입, if 한 번, 상수 크기 작업
- **O(log n) (로그 시간)**
    - 입력이 커져도 증가가 느림
    - 예: 이분 탐색, 트리 높이에 비례하는 연산(균형 트리)
- **O(n) (선형 시간)**
    - 입력 크기에 비례해서 증가
    - 예: 한 번 순회(단일 for문)

---

## 2) Big-O 표기법

### 의미

- Big-O는 **n이 커질 때 지배적인 증가율(성장률)** 만 남기는 표기이다.
- 따라서 **상수 계수와 낮은 차수 항은 무시**한다.

### 예시

- `10n^2 + n` → **O(n²)**
    - 가장 큰 항 `n²`가 성장률을 지배하므로 나머지는 무시한다.

---

## 3) 성장률(영향력) 순서

입력이 커질수록 더 빨리 증가하는 순서:

**n! > 2^n > n^2 > n > log n > 1**

- `n!`, `2^n`: 조합/부분집합 완전탐색에서 자주 등장(입력이 조금만 커져도 폭발)
- `n^2`: 이중 반복
- `n`: 단일 순회
- `log n`: 이분 탐색류
- `1`: 상수 시간

---

## 4) 자료구조의 시간 복잡도

### 배열(Array) / 벡터(Vector)

- **인덱스 접근(access)**: **O(1)**
- **값 탐색(search, 선형 탐색)**: **O(n)**
- **끝 삽입/삭제** `push_back / pop_back`: **상환 O(1)**
    - (가끔 capacity 재할당 시 **O(n)** 발생)
- **앞 삽입/삭제**: **O(n)**
- **중간 삽입/삭제**: **O(n)**
    - (요소를 밀거나 당겨야 함)

> 핵심: 랜덤 액세스가 빠르다. 대신 앞/중간 수정은 오래거림
> 

### 스택(Stack)

- **top(맨 위 확인)**: **O(1)**
- **push / pop**: **O(1)**

> 특징: LIFO(마지막에 넣은 게 먼저 나옴)
> 

### 큐(Queue)

- **front/back(앞/뒤 확인)**: **O(1)**
- **push / pop**: **O(1)**

> 특징: FIFO(먼저 들어온 게 먼저 나옴)
> 

### 덱(Deque)

- **front/back 접근**: **O(1)**
- **push_front / push_back / pop_front / pop_back**: **O(1)**

> 특징: 양쪽 끝에서 삽입/삭제가 모두 빠름(슬라이딩 윈도우에 자주 사용)
> 

### 연결 리스트(Linked List)

- **인덱스 접근(access)**: **O(n)**
- **탐색(search)**: **O(n)**
- **삽입/삭제(insert/erase)**: **O(1)**
    - **단, “해당 위치의 노드/이터레이터를 이미 알고 있을 때”만 O(1)**
    - 위치를 찾는 과정이 필요하면 **찾기 O(n)** 이 추가됨

> 핵심: “중간 삽입/삭제가 빠르다”는 말은 위치 포인터가 있을 때만 맞다.
> 

### 맵(Map) / 셋(Set)

- **조회(find)/삽입(insert)/삭제(erase)**: **O(log n)**
- **정렬된 순서 유지**, `lower_bound/upper_bound` 가능

### 해시맵(Unordered Map) / 해시셋(Unordered Set)

- **평균** 조회/삽입/삭제: **O(1)**
- **최악**: **O(n)** (충돌이 심하거나 특수 상황)
