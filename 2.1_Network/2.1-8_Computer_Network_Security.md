# 2.1–8 Computer Network Security

> Active recall
> 
> - Can you explain each of the **four goals of network security (confidentiality, integrity, authentication, operational security)** in one sentence?
> - If you divide an attacker’s actions into the four types **sniffing / tampering / injection / deletion**, can you describe an example scenario for each?
> - Can you clearly distinguish and explain what **plaintext / ciphertext / key** are?
> - From the perspective of “how the key is shared,” can you explain the main difference between **symmetric-key encryption** and **public-key encryption**?
> - Why do real-world protocols use a **hybrid scheme that combines public-key and symmetric-key encryption**?
> - When we say **message integrity** is guaranteed, what two things (source, content) does that statement precisely mean?
> - Compared to simply sending (m, H(m)), why is it more secure to compute the hash together with a secret key as in **MAC(H(m + s))**?
> - For **MAC** and **digital signatures**,
>     
>     can you briefly compare them in terms of
>     
>     “whether you can identify exactly who created it” and “whether public/private keys are used”?
>     
> - Why is **IP-address-based authentication** dangerous? Can you explain it using **IP spoofing** as an example?
> - Can you explain how a **nonce-based challenge–response** scheme prevents replay attacks?
> - Can you describe the two core goals of the **TLS handshake** (server authentication and key agreement) along with the rough flow?
> - In TLS data transfer, why is the structure **record + sequence number + HMAC + encryption** necessary (for integrity + order guarantees)?
> - Can you say which layer **IPsec** operates at and list the functions it provides (confidentiality, source authentication, integrity, replay protection)?
> - Can you explain the difference between **AH** and **ESP** based on whether they provide **confidentiality (encryption)**?
> - In a **VPN (tunnel mode)**, what does it mean to “encrypt the entire original IP packet and wrap it in a new IP header,” and why does this make it look like a virtual private network?
> - For 802.11 Wi-Fi security, can you explain in one line each of the two core problems it tries to solve:
>     
>     (**mutual authentication** between station and AP, and **link-layer encryption** over the wireless segment)?
>     
> - In 4G/5G authentication, can you explain at a high level how the device and the network authenticate each other using the **shared secret key K(IMSI) between the device and the HSS**?
> - Can you explain the difference in roles between a **firewall** and **IDS/IPS**,
>     
>     in terms of “policy-based first gatekeeper” vs. “systems that analyze traffic contents to detect/block attacks or anomalies”?
>     

---

## 8.1 What Is Network Security?

### 1. Overview

- Network security refers to **all technologies and procedures** that allow a sender and receiver to **communicate safely even over a public network (the Internet)**.
- The key is to prevent a third party, an **intruder/attacker**, from **eavesdropping on, modifying, or spoofing** the communication.

### 2. Four Properties Required for Secure Communication

**1) Confidentiality**

- Only the **sender and the designated receiver** should be able to understand the message contents.
- Even if an attacker **snoops** on the message, encryption should be used so that they **cannot interpret** it.

**2) Message Integrity**

- We must ensure that the message has **not been altered in transit**.
- Even if an attacker **modifies, inserts, or deletes** parts of the message,
    
    the receiver must be able to **detect** this.
    
    - Example: use a hash, MAC (Message Authentication Code), etc. to verify.

**3) Endpoint Authentication**

- This ensures that the communication peer is **really the person/server they claim to be**.
- Examples:
    - When you connect to something you believe is a “bank server,” you need to verify that it is **actually the real bank server**, not an attacker.
    - During login, you verify identity using ID/password, certificates, OTP, etc.

**4) Operational Security**

- Today, most organizational networks are **connected to the public Internet**.
- Therefore, you need **operational and management security** for the network itself to defend against external attacks, such as:
    - deploying firewalls
    - intrusion detection/prevention systems (IDS/IPS)
    - access control policies
- This is about **how to manage and operate the organization’s network securely as a whole**.

### 3. Security Scenario Structure

**1) Actors**

- **Sender / Receiver (Alice, Bob)**
    - To communicate securely, they **encrypt some or all of the data**.
    - They use security protocols that satisfy the properties of confidentiality, integrity, and authentication mentioned above.
- **Intruder/Attacker (Trudy)**
    - She secretly taps into the network channel and attempts actions such as:
        - **Sniffing**: **eavesdropping on and recording** control and data messages
        - **Tampering**: **modifying** message contents
        - **Injection**: **inserting** fake messages
        - **Deletion**: **removing** specific messages
    - The goal of network security is to **maintain confidentiality, integrity, authentication, and operational security of the communication** even in the face of such attacks.

---

## 8.2 Principles of Cryptography

### 1. Basic Concepts

- **Plaintext**
    
    The **original message** that humans can read.
    
- **Ciphertext**
    
    The result of transforming plaintext using an **encryption algorithm plus a key**; it is not meaningful to a human reader.
    
- **Key**
    
    A **secret value** used for encryption and decryption.
    
    → The algorithm itself can be public; the goal is to make it **hard to recover the plaintext without knowing the key**.
    

### 2. Symmetric-Key Encryption

**1) Concept**

- Encryption and decryption use **the same key**.
- The sender and receiver must **securely share the secret key in advance**.

**2) Classical Examples**

- **Caesar Cipher**
    
    Each letter of the alphabet is shifted by a fixed number of positions (k).
    
    → The key is “how many positions it is shifted.”
    
- **Monoalphabetic Substitution Cipher**
    
    Each character is mapped **one-to-one to another character**.
    
    → Vulnerable to frequency analysis.
    
- **Polyalphabetic Substitution Cipher**
    
    Different substitution tables are used depending on the position in the message.
    
    → The same character can yield different ciphertext characters depending on its position.
    

> These are historical/educational examples and are not used in modern security.
> 

**3) Block Ciphers and CBC (Modern Symmetric-Key Concept)**

- Modern symmetric-key schemes usually use **block ciphers**.
    - The data is split into **k-bit blocks** (e.g., 128 bits),
    - and each block is transformed into another k-bit block using a key.
    - Examples: AES (and historically, DES).
- If you use a naive block cipher:
    - The same plaintext block → always the same ciphertext block, which can **reveal patterns**.
- The idea of **CBC (Cipher Block Chaining)**:
    - “For each block, **mix in the previous ciphertext block** when encrypting.”
    - This way, even if the plaintext blocks are the same, the result changes depending on the previous ciphertext, hiding patterns.
    - For the first block, an **initialization vector (IV)**, a random value, is used.

### 3. Public-Key Encryption

**1) Concept**

- Uses **two different keys**:
    - **Public key**: can be safely published
    - **Private key**: kept secret by the owner
- Communication pattern:
    - Sender: encrypts with the receiver’s **public key**
    - Receiver: decrypts with their **private key**

→ This allows you to start secure communication **without having to secretly share a key beforehand**.

**2) Core Idea of RSA**

- **RSA** is a representative public-key encryption algorithm.
- It is based on **modular arithmetic (remainder operations) on large numbers**
    
    and on the fact that **factoring such numbers back into primes is extremely hard**.
    
- The public key (n, e) is known to everyone,
    
    but factorizing n back into two primes p and q is computationally difficult,
    
    so it is considered hard to derive the private key.
    

### 4. Hybrid Encryption

- **Problem**
    - Public-key algorithms (e.g., RSA) are **slow**.
    - Symmetric-key algorithms (e.g., AES) are **fast**, but key sharing is the problem.
- **Solution – use both together**
    1. The sender generates a temporary **session key (symmetric key)**.
    2. The sender encrypts this session key with the receiver’s **public key** and sends it.
    3. The receiver decrypts the session key with their **private key**.
    4. All actual data is then encrypted quickly using this session key and a **symmetric cipher**.

→ This is the structure used in real-world protocols such as **TLS/HTTPS**.

---

## 8.3 Message Integrity and Digital Signatures

### 1. Message Integrity

- Things we want to guarantee:
    1. **Did this message really come from the claimed sender?** (source authentication)
    2. **Was the content unchanged during transmission?** (content integrity)

### 2. Cryptographic Hash Functions

- A hash function takes a message `m` and outputs a **fixed-length value H(m)**.
- Properties:
    - Even if `m` changes only slightly, H(m) should change a lot.
    - It should be **computationally hard to find two different messages `x, y` such that H(x) = H(y)** (collision resistance).
- Examples: MD5, SHA family (you just need to know the names here).

### 3. MAC (Message Authentication Code)

**1) Problem with just attaching a hash**

- If you only send (m, H(m)):
    - An attacker can choose any `m'`, compute H(m'), and send (m', H(m')).
    - → You cannot tell **who** actually sent it.

**2) MAC using a secret key**

- Assume the sender and receiver share a **secret key s**.
- Sender: sends (m, H(m + s))
- Receiver: recomputes H(m + s) with the same key s and compares it with the attached value.
    
    → If they match, then:
    
    - The message has **not been modified in transit**, and
    - It must have come from someone who knows the **secret key s** (a legitimate sender).
- In practice, HMAC (e.g., HMAC-SHA-256) is widely used.

### 4. Digital Signatures

**1) Purpose**

- To verify **who** agreed to/approved this message.
- To confirm **that person really signed it**.
- To check whether the content has **changed after signing**.

**2) Basic idea**

- Uses public/private keys.
- Signer:
    - Computes the hash H(m) of message m.
    - Encrypts H(m) with their **private key** → this becomes the digital signature.
- Verifier:
    - Decrypts the signature using the signer’s **public key** to obtain h.
    - Recomputes H(m) from the received message m.
    - If the two values match:
        - The signer is indeed the **owner of the private key**, and
        - The message has **not been tampered with**.

### 5. MAC vs Digital Signature

- **MAC**:
    - Generated using a **shared secret key**.
    - Fast and lightweight, but if multiple people share the same key, you **cannot tell exactly who created it**.
- **Digital Signature**:
    - Signed with a **private key**, verified by anyone using the **corresponding public key**.
    - You can precisely identify the signer, which is important for things like legal validity and contracts.

---

## 8.4 Endpoint Authentication

### 1. What Is Endpoint Authentication?

- **Endpoint authentication** is the process of proving on the network that the peer you’re talking to is **really that person/host**.
- Like an email client and mail server: the protocol typically **authenticates first, then does everything else**.

### 2. Authentication Protocol ap 2.0 — IP-Address-Based (Insecure)

- Idea:
    - Assume the sender’s IP address is known in advance.
    - The receiver “authenticates” by checking whether the **source IP field in the IP header matches** that address.
- Problem:
    - Anyone can craft a packet with an arbitrary source IP address → **IP spoofing** is possible.
    - Therefore, this is **not a secure authentication method**.

### 3. Authentication Protocol ap 3.0 — Password in Cleartext (Eavesdropping Vulnerable)

- Idea:
    - The sender and receiver use a **shared password** to authenticate.
    - Similar to normal **password login** for services like Gmail, Facebook, etc.
- Problem:
    - If the password is sent **as-is (or in an easily reversible form)**,
    - An attacker can eavesdrop, learn the password, and **reuse it later while pretending to be the user**.

### 4. Authentication Protocol ap 3.1 — Encrypted Password (Replay Vulnerable)

- Improvement:
    - Instead of sending the password in plaintext,
    - The sender encrypts the password using a **shared symmetric key**, and sends the encrypted password.
- Still problematic:
    - An attacker can **record the encrypted password itself**,
    - And later resend it as-is; the receiver will mistakenly accept it as a valid login.
    - → This is a **replay (playback) attack**.

### 5. Authentication Protocol ap 4.0 — Nonce-Based Challenge–Response

- A **nonce** is a random number that is used **only once** during a protocol run.

**Operation**

1. The sender sends a message to the receiver saying “authenticate me.”
2. The receiver generates a random nonce R and sends it to the sender.
3. The sender encrypts R using the **shared symmetric key** to obtain K(R), then sends K(R) back.
4. The receiver, who also knows the same secret key, encrypts R and compares:
    - If the value matches, the receiver concludes that the peer is a **legitimate sender who knows the secret key**.

**Key points**

- Because a **different nonce** is used each time:
    - Replaying an old K(R_old) that was previously eavesdropped **won’t work this time**.
    - → This prevents replay attacks.
- Thus, ap 4.0 is an example of **secure endpoint authentication** using a **symmetric key + nonce-based challenge–response**.

---

## 8.5 Security in Electronic Mail

### 1. Why Provide Security at Multiple Layers?

- Security mechanisms can be placed at **any layer**: link, network, transport, or application.
- Using only the **network layer (e.g., IPsec)** is not enough to solve **user-level security** problems.
    - Example: For an online shop to verify “Is this user really this account’s owner?”, IP-level security alone is insufficient.
- If we add security at the **application layer**, applications that use that protocol (e.g., email) can directly make use of those security services.

### 2. Secure Electronic Mail

**1) Confidentiality**

- The email content is encrypted with a **symmetric key (e.g., AES, DES)** to provide confidentiality.
- The problem is how to **securely share this symmetric key** so that only the sender and receiver know it.
- Encrypting the entire email with public-key (RSA) is too computationally expensive, so we use a **hybrid approach: session key (symmetric) + public key**.

**Hybrid encryption procedure (for email confidentiality)**

1. The sender chooses a random **symmetric session key Ks**.
2. The sender encrypts the message m with Ks → ciphertext 1.
3. The sender encrypts Ks itself with the **receiver’s public key** → ciphertext 2.
4. The sender sends (ciphertext 1, ciphertext 2) to the receiver.
5. The receiver uses their **private key** to decrypt ciphertext 2 and obtain Ks.
6. Using Ks, the receiver decrypts ciphertext 1 to recover m.

→ The email content is protected by a **fast symmetric cipher**, while the session key is delivered using **public-key encryption**.

**2) Sender Authentication + Message Integrity**

- Tools used: **hash function + digital signature**.

**Procedure**

1. The sender applies a hash function to message m → computes **H(m)** (a digest).
2. The sender encrypts H(m) with their **private key** → this is the digital signature.
3. The sender transmits (m, signature) to the receiver.
4. The receiver uses the sender’s **public key** to decrypt the signature → obtains h.
5. The receiver applies the same hash function to the received m → computes H(m).
6. If h = H(m), then:
    - The signature was created by the **owner of the corresponding private key**, and
    - m has **not been altered during transmission**.

**3) Putting It Together: “Sign, then Encrypt”**

- Real secure email systems combine the two processes above.
1. First, for **sender authentication + integrity**, the sender creates a bundle (m, signature).
2. This entire bundle is treated as one message and subjected to the confidentiality process:
    - encrypt it with a **session key**,
    - encrypt the session key with the receiver’s **public key**.
3. The receiver reverses the steps:
    - decrypt with their private key to get the session key,
    - decrypt the bundle with the session key,
    - verify the signature and integrity.
- Both sides must know each other’s **public keys** correctly.
    
    In practice, a **Certificate Authority (CA)** is used to certify and distribute public keys.
    

### 3. PGP (Pretty Good Privacy)

- PGP is a concrete software example for **secure email**, and it uses essentially the **same combined structure** described above.

**Key features of PGP**

1. When installed, it generates a **public/private key pair** for each user.
    - Public keys can be uploaded to websites or public key servers.
    - Users can sign each other’s public keys, forming a **web of trust**.
2. The **private key is protected by a password**, and the user must enter the password whenever they use the private key.
3. For any given email, the user can choose to:
    - **sign only**,
    - **encrypt only**, or
    - **both sign and encrypt**.

---

## 8.6 Securing TCP Connections: TLS

### 1. What is TLS?

- **TLS (Transport Layer Security)** is a **security protocol that runs on top of TCP**.
- It provides:
    - **Confidentiality**: protects the content via encryption
    - **Integrity**: checks whether data has been altered (e.g., using HMAC)
    - **Server authentication** and, if needed, **client authentication** as well

### 2. TLS Phases

**1) Handshake**

- Goals:
    - **Verify that the server is genuine** (server certificate + CA)
    - Agree on a **shared secret (MS/PMS)** that only the two parties know, which will be the basis for session keys
- Mechanism:
    - The client and server use **public-key cryptography + random nonces** to derive a shared secret value (MS) that only they know.

**2) Key Derivation**

- From a single secret value (MS/PMS), they derive:
    - **Client → Server encryption key**
    - **Server → Client encryption key**
    - **HMAC keys** for both directions
- In this way, multiple **session keys** are generated and used.

**3) Data Transfer**

- Application data is split into **TLS records**.
- For each record:
    1. Compute an HMAC over **sequence number + data** → ensures integrity and ordering
    2. Encrypt the result (data + HMAC) with the **session key**, then send it over TCP
- The receiver uses the same key and sequence number to recompute the HMAC and **check for tampering or reordering**.

**4) Connection Termination**

- Instead of just using a bare TCP FIN,
    
    TLS sends a special **“close/alert record” that is itself encrypted and HMAC-verified**,
    
    making it harder for an attacker to arbitrarily terminate the session.
    

### 3. One-Line Summary

> TLS authenticates the server and agrees on a secret key during the handshake,
> 
> 
> then uses **record-level encryption + HMAC + sequence numbers**
> 
> to turn a TCP connection into one that provides **confidentiality, integrity, and authentication**.
> 

---

## 8.7 Network-Layer Security: IPsec and Virtual Private Networks

### 1. What is IPsec?

- **IPsec (IP Security)** is a suite of security protocols that operate at the **IP layer**.
- It provides:
    - **Confidentiality**: encrypts the payload of IP packets
    - **Source authentication**
    - **Data integrity**
    - **Replay protection**

### 2. Private Networks vs VPNs

- In the past: organizations built **physically separate private networks** (dedicated lines, dedicated routers) between sites → very expensive.
- Today: they use **VPNs (Virtual Private Networks)**.
    - Actual traffic traverses the **public Internet**,
    - but at the edge, it is **encrypted using IPsec**,
        
        creating a tunnel that behaves like a **secure internal private network**.
        

### 3. AH vs ESP

Two main IPsec protocols:

- **AH (Authentication Header)**
    - Provides source authentication and integrity
    - Does **not** provide encryption (no confidentiality)
- **ESP (Encapsulation Security Payload)**
    - Provides source authentication, integrity, and **confidentiality**
    - In practice, implementations **almost always use ESP**

### 4. SA, SAD, SPD (Key Concepts)

- **SA (Security Association)**
    - A **logical security connection** in IPsec
    - It is **one-way**, so typical bidirectional communication uses **two SAs**
    - Specifies which algorithms, which keys, and which direction of traffic are protected
- **SAD (Security Association Database)**
    - A table that stores information about multiple SAs
- **SPD (Security Policy Database)**
    - A policy table that decides **whether a given packet should use IPsec and, if so, which SA to use**
    - In short:
        - **SPD**: decides *what to protect* and *which SA* to use
        - **SAD**: holds the *detailed settings* (algorithms, keys, etc.) for each SA

### 5. IPsec + VPN Operation (Tunnel Mode)

- The organization’s router/VPN gateway **wraps the entire original IP packet in ESP and encrypts it**,
    
    then attaches a **new outer IPv4 header** and sends it across the Internet.
    
- Routers on the Internet **only look at the outer IP header** to route the packet.
- At the tunnel endpoint, the ESP part is decrypted and the **original IP packet** is restored and delivered into the internal network.
- As a result, site-to-site traffic moves through an **encrypted tunnel**, hiding both the content and the internal addressing from outsiders.

### 6. IKE (Key Exchange – Concept Only)

- **IKE (Internet Key Exchange)** is the protocol IPsec uses to:
    - Automatically set up SAs, and
    - Automatically exchange/generate the necessary **cryptographic keys**.
- High-level idea:
    - Peers use their **certificates (public keys)** to authenticate each other,
    - Perform Diffie–Hellman to create a **shared secret**,
    - And derive **session keys** for multiple IPsec SAs from that secret.

---

## 8.8 Wireless LAN and 4G/5G Cellular Network Security

### 802.11 (Wi-Fi) Wireless LAN Security

**1) Key Security Goals**

- **Mutual authentication**
    - Device → “Is this AP/network really genuine?”
    - Network → “Is this device actually allowed to connect?”
- **Encryption**
    - Since wireless signals are **broadcast over the air**,
    - **Link-layer frames between the device and AP are encrypted with a symmetric key** (e.g., AES).

**2) Basic Flow**

1. **Discovery**
    - The AP advertises the authentication/encryption methods it supports.
    - The device chooses and requests a method it wants to use.
2. **Mutual authentication + Session key generation**
    - Assume the device and the authentication server already share some **secret (e.g., a password)**.
    - Using nonces, MAC addresses, and the shared secret,
        
        they derive a **shared symmetric session key**.
        
3. **Session key distribution**
    - The authentication server sends the generated session key to the AP.
    - As a result, **the device and AP share the same session key**.
4. **Encrypted data transfer**
    - From then on, all data frames between the device and AP
        
        are encrypted with this session key using **symmetric encryption (AES)**.
        

**3) WEP → WPA1 → WPA2**

- **WEP**: first standard, has serious security flaws.
- **WPA1**: improved integrity checks, mitigated key recovery attacks.
- **WPA2**: mandates **AES-based symmetric encryption**, and is effectively the standard today.

**4) EAP-Based Authentication Architecture**

- **EAP**: defines the format for authentication messages end to end.
- **EAPoL**: encapsulates EAP messages between device and AP at layer 2.
- The AP re-encapsulates these in **RADIUS/UDP/IP** and forwards them to the **authentication server**.

→ The key idea to remember is the **three-party structure (device–AP–authentication server)** performing mutual authentication and key agreement.

### 4G/5G Cellular Network Security

**1) Goals**

- Just like 802.11:
    - **Mutual authentication between device and network**, and
    - Agreement on **encryption/decryption keys** to be used afterward.

**2) Main Components**

- **UE (User Equipment)**: phone, modem, etc.
- **Base station + MME (for 4G)**: handle radio access and control plane.
- **HSS**: home subscriber server holding subscriber information and secret keys.
- **IMSI**: International Mobile Subscriber Identity used to identify the subscriber.
- **Pre-shared secret key K(IMSI)**: known only to the device and the HSS.

**3) 4G Authentication and Key Agreement (High-Level Flow)**

1. **Authentication request**
    - The device requests network access via the base station.
    - The MME sends an authentication request to the HSS, including the device’s **IMSI** and related info.
2. **HSS response (auth_token, xres)**
    - Using the pre-shared secret K(IMSI), the HSS computes:
        - **auth_token**: a value that proves “whoever created this token knows K(IMSI).”
        - **xres**: the “expected response” that the MME will later use to verify the device.
    - The MME stores xres and forwards auth_token to the device.
3. **Device’s authentication response**
    - The device uses its secret K(IMSI) to process auth_token,
        
        confirming that the token **came from the genuine HSS** (authenticates the network).
        
    - Using the same secret, it computes **res** and sends it back to the MME.
4. **Device authentication + key agreement**
    - The MME compares res from the device with xres from the HSS.
        
        → If they match, the device is authenticated as a **legitimate subscriber who knows K(IMSI)**.
        
    - The MME, base station, and device then derive
        
        **encryption/decryption keys for the radio data plane and control plane** from the shared secret.
        

### One-Line Summary

- **802.11 Wi-Fi**:
    
    → Uses a device–AP–authentication server architecture for **mutual authentication + session key generation**, then encrypts link-layer frames with **AES**.
    
- **4G/5G cellular**:
    
    → Uses a **pre-shared secret K(IMSI) between the device and HSS** to perform **mutual authentication** and
    
    derive **encryption keys for the wireless link**.
    

---

## 8.9 Operational Security: Firewalls and Intrusion Detection Systems

### 1. Firewalls

- **Definition**
    - A firewall is a device or software placed between an organization’s internal network and the Internet that **allows some packets through and blocks others** based on policy.
- **Goals**
    1. Ensure that **all inbound and outbound traffic** between internal and external networks **passes through the firewall**.
    2. Only traffic that is **explicitly allowed by the security policy** is permitted.
    3. The firewall itself must be **resilient against attacks**.

**(1) Traditional Packet Filter**

- Implemented on a gateway router (often at the ISP edge), and makes decisions by looking **only at header fields**.
- Typical filtering criteria:
    - Source/destination **IP address**
    - **Protocol type** (TCP, UDP, ICMP, etc.)
    - Source/destination **port number**
    - **TCP flag bits** (SYN, ACK, etc.)
    - ICMP type
    - Different rules for inbound vs outbound traffic
- These rules are usually implemented as an **Access Control List (ACL)** on the router.

**(2) Stateful Packet Filter**

- Tracks the **state of TCP connections** and makes allow/deny decisions based on that.
- By watching SYN, SYN-ACK, ACK, FIN, etc., it maintains a table describing **which connections currently exist**.
- It can then check whether a packet from outside is **part of an already established legitimate connection**, and filter out forged or suspicious packets more effectively.

**(3) Application Gateway (Proxy)**

- A **proxy server** through which **all application data** for a given application (HTTP, Telnet, etc.) must pass.
- Example: “Only some internal users are allowed to use Telnet to the outside.”
    - Packet filters on routers are configured so that **all Telnet traffic must go through the gateway only**.
    - Users first log in to the gateway (ID/password).
    - After checking authorization, the gateway **opens the connection to the external host on the user’s behalf** and relays the data.
- **Drawbacks**
    1. You need a separate gateway for each application protocol.
    2. All traffic must pass through the gateway → potential **performance bottleneck**.
    3. Clients need to know **how to connect via the gateway**, not directly.

**(4) Anonymity & Privacy (Proxy + SSL)**

- If you don’t want your own IP address and access history to be exposed directly, you can use a combination of a **trusted proxy server + SSL**.
- The link between client and proxy is encrypted with SSL,
    
    while the proxy–web server link may use plain HTTP.
    
- However, because the proxy sees **all of the content**, the proxy itself must be **highly trusted**.

### 2. Intrusion Detection Systems (IDS/IPS)

- **IDS (Intrusion Detection System)**
    - Monitors traffic in detail and **raises an alert when suspicious or malicious activity is detected**.
- **IPS (Intrusion Prevention System)**
    - Not only detects suspicious traffic but **actively blocks it**.
- In practice, both are often loosely referred to as “IDS systems.”
- Multiple IDS sensors can be deployed throughout the network,
    
    and a central IDS process aggregates information so administrators can understand the overall security status.
    

**(1) Signature-Based IDS**

- Maintains a large database of **attack signatures (patterns)**.
- Each signature may:
    - Describe characteristics of a single packet, or
    - Describe patterns spread across multiple packets.
- As packets flow by, the IDS continuously compares them against the signature database,
    
    and if there is a match, it **raises an alert**.
    
- **Limitations:**
    - Vulnerable to **new/unknown attacks** that are not yet in the signature database.
    - Comparing every packet against many signatures is **computationally heavy** and can impact performance.

**(2) Anomaly-Based IDS**

- First observes network traffic over time to learn what **normal patterns and statistics** look like.
- Later, if it detects **statistically abnormal traffic**, such as a surge in ICMP packets or a spike in port-scan patterns,
    
    it raises an alert.
    

### One-Line Summary

> A firewall is the first gate that enforces policy on what traffic is allowed in or out,
> 
> 
> while **IDS/IPS** sit behind it and **inspect traffic more deeply** to detect
> 
> **known attack signatures** and **statistical anomalies** in order to protect the network.
>
