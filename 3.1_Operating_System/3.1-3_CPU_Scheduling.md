# 3.1-3 CPU Scheduling

> Active recall
> 
> - What is the **main goal** of CPU scheduling?
>     
>     (When the OS decides “which process should get the CPU right now,” which performance metrics is it trying to optimize?)
>     
> - Explain the difference between a **CPU-bound process** and an **I/O-bound process**,
>     
>     and why taking this difference into account improves overall system performance.
>     
> - Explain the difference between **preemptive** and **non-preemptive** scheduling,
>     
>     and compare in which situations each is advantageous and what drawbacks they have.
>     
> - For FCFS, SJF/SRTF, Round Robin, and Priority scheduling,
>     
>     summarize in one line **what criterion** each algorithm uses to pick the next process.
>     
>     (Focus on *what it prioritizes*, not detailed formulas.)
>     
> - In SJF/SRTF and Priority scheduling, under what circumstances can **starvation** occur,
>     
>     and how does **aging** help mitigate this problem?
>     
> - Explain the difference between **Multilevel Queue** and **Multilevel Feedback Queue** scheduling,
>     
>     especially in terms of **whether processes can move between queues**, and why MLFQ is often considered a **practical, realistic scheduling strategy**.
>     

---

## Overview of CPU Scheduling

When multiple processes exist at the same time, **they all want to use the CPU.**

But at any given moment, the CPU can execute **only one process**.

So the operating system must decide:

> “Right now, which process should get the CPU?”
> 
> 
> → The mechanism that makes this decision is called **CPU scheduling**.
> 

---

### Goals of CPU Scheduling

Representative performance metrics:

- **CPU utilization**
    - Keep the CPU **as busy as possible**, avoiding idle time.
- **Throughput**
    - The number of **processes completed per unit time**.
- **Turnaround time**
    - The total time from when a process **arrives** until it **finishes**.
- **Waiting time**
    - The total time a process spends **waiting in the ready queue**.
- **Response time**
    - The time until the **first response** is produced.
    - Especially important in **interactive systems**.

→ In general, scheduling algorithms aim for:

**“High CPU utilization / throughput, low waiting and response time.”**

---

### CPU-bound vs I/O-bound Processes

- **CPU-bound job**
    - Spends most of its time doing **CPU computation**.
    - Examples: heavy numerical computations, batch jobs, etc.
- **I/O-bound job**
    - Uses the CPU briefly, but spends most of its time **waiting for I/O**.
    - Examples: programs that frequently wait for user input, disk I/O, or network I/O.

For an efficient system:

> It is often good to give I/O-bound processes CPU promptly,
> 
> 
> let them quickly issue their I/O requests and go back to the waiting state,
> 
> and then use the CPU for CPU-bound processes while the I/O completes.
> 

Therefore, the scheduler can **assign priorities** based on the **nature and importance** of processes.

---

### Scheduling Queues

Depending on their situation, processes wait in **different queues**.

- **Ready queue**
    - Queue of processes that are **ready to run** and
        
        would start executing immediately **if given the CPU**.
        
- **Wait / blocked queue**
    - Queue of processes that are **blocked** while waiting for a specific event,
        
        such as disk I/O, keyboard input, network responses, etc.
        

The OS:

- Picks the next process to run from the **ready queue**,
    
    using a **scheduling algorithm** (FCFS, SJF, RR, etc.), and if needed, **priorities**.
    
- When a process in a **wait queue** finishes its I/O or event,
    
    it is moved back to the **ready queue**.
    

---

### Preemptive vs Non-preemptive Scheduling

**Scenario:**

Process A is currently using the CPU, when a **more urgent process B** arrives. What should the OS do?

### Non-preemptive scheduling

- Once a process gets the CPU:
    - It keeps it **until it voluntarily gives it up**,
        
        e.g., by terminating or blocking for I/O.
        
- Other processes **cannot forcibly take the CPU away**.
- Simple to implement, but response times can be long.

### Preemptive scheduling

- The OS uses mechanisms like **timer interrupts** to:
    - Decide “your turn is over; someone else needs the CPU now” and
        
        **forcibly take the CPU away from the running process.**
        
- Pros:
    - Prevents one process from **monopolizing** the CPU.
    - Improves **response time** in interactive systems.
- Cons:
    - **More frequent context switches** → higher overhead.

> Most modern general-purpose OSes (Windows, Linux, macOS, etc.)
> 
> 
> use **preemptive scheduling**.
> 

---

## CPU Scheduling Algorithms

Here are some representative algorithms.

### FCFS (First-Come, First-Served)

- Assigns the CPU to processes in the **order they arrive in the ready queue**.
- A **non-preemptive** algorithm.

**Drawback: Convoy effect**

- If a process that **needs the CPU for a long time** arrives first,
    - all the **short jobs behind it** must wait until it finishes.
- This can lead to very **poor average waiting time**.

---

### SJF (Shortest Job First)

- Runs the process with the **shortest CPU burst time** first.
- Basic SJF is **non-preemptive**:
    - Once a process starts its CPU burst, it runs to completion for that burst.

**Advantage**

- Theoretically, SJF **minimizes average waiting time**
    
    (under the assumption that CPU burst times are known exactly).
    

**Disadvantages**

- Long CPU-bound processes may be **continually postponed** by short jobs,
    
    leading to **starvation**.
    
- In practice, the OS does not know exact CPU burst times,
    
    so it must use **predictions** based on past behavior.
    

---

### SRT (SRTF) – Shortest Remaining Time First

- The **preemptive version of SJF**.
- If a new process arrives with a **shorter remaining CPU time**
    
    than the currently running process,
    
    - the scheduler **preempts** and gives the CPU to the process with the **shortest remaining time**.

**Characteristics**

- Always chooses the process with the **smallest remaining CPU burst**.
- Like SJF, can also suffer from **starvation** of longer jobs.

---

### Round Robin (RR)

- Essentially **FCFS + time slice (time quantum)**.
- Processes in the ready queue get the CPU in **arrival order**, but:
    - Each process can use the CPU only for a fixed **time quantum**.
    - When its time is up, it goes to the **back of the ready queue**.

**Importance of the time quantum**

- If it is too large:
    - Behavior becomes similar to **FCFS**, and response time worsens.
- If it is too small:
    - Context switches become very frequent → **high overhead**.

> Round Robin is widely used in interactive systems
> 
> 
> because it balances **fairness** and **responsiveness** reasonably well.
> 

---

### Priority Scheduling

- Each process is given a **priority**, and
    - the scheduler always runs the process with the **highest priority** first.
- Can be **preemptive or non-preemptive**:
    - Preemptive: if a higher-priority process arrives, it preempts the current one.
    - Non-preemptive: the current process finishes or blocks before switching.

**Problem: Starvation**

- Low-priority processes may be **continually pushed back**
    
    and might **never get the CPU**.
    

**Solution: Aging**

- **Gradually increase the priority** of processes that have been waiting for a long time.
- Ensures that, given enough time, **every process eventually gets a chance to run**.

---

### Multilevel Queue Scheduling

- Instead of a single ready queue,
    
    the scheduler uses **multiple ready queues** based on priority or type of process.
    
    - Example:
        - Interactive process queue
        - Batch job queue
        - System process queue, etc.

Characteristics:

- There is a **priority among queues**:
    - Processes in higher-priority queues are **scheduled first**,
        
        and only when they are empty does the scheduler consider lower-priority queues.
        
- Each queue can use a **different scheduling algorithm**.
    - Example: upper queue uses RR, lower queue uses FCFS.
- In the basic multilevel queue model, processes **do not move between queues**;
    
    once assigned to a queue, they stay there.
    

---

### Multilevel Feedback Queue Scheduling (MLFQ)

- Similar to Multilevel Queue, but with one key difference:

> In MLFQ, processes can move between queues.
> 

General idea:

- New processes usually start in a **higher-priority queue**.
    - If a process **uses up its time slice** without finishing,
        - it is **moved down** to a lower-priority queue.
    - Thus, processes that use the CPU heavily tend to **drift down** to lower queues.
- Conversely, processes that have **waited too long** in lower queues
    - can be **moved up** to higher-priority queues to avoid starvation.

Advantages:

- **Interactive jobs** (short, frequent CPU bursts)
    
    are served quickly from higher-priority queues.
    
- **CPU-bound jobs** gradually move to lower queues,
    
    helping balance overall performance and responsiveness.
    
- MLFQ is widely considered a **practical scheduling strategy** and is used (in variants) by real operating systems.
