# 3.1-4 동기화

> Active recall
> 
> - **동기화(synchronization)** 의 두 가지 핵심 목적은 무엇이었지?
>     
>     (실행 순서 제어와 상호 배제 관점에서 각각 설명해봐라.)
>     
> - **공유 자원 / 임계 구역 / 레이스 컨디션** 세 가지 개념의 관계를 정리해봐라.
>     
>     (각각이 무엇이고, 왜 레이스 컨디션이 생기는지 흐름으로 설명해봐라.)
>     
> - 생산자–소비자(Producer–Consumer) 문제를 예로 들어,
>     
>     왜 **상호 배제**가 필요하고, 왜 **실행 순서 제어(조건 동기화)** 도 동시에 필요한지 말해봐라.
>     
> - **뮤텍스 락(Mutex)** 과 **세마포어(Semaphore)** 를 비교해봐라.
>     - 공통점: 둘 다 무엇을 위해 쓰이고?
>     - 차이점: 표현할 수 있는 자원 개수, 사용 패턴(1개 vs N개), busy wait / block-wakeup 관점에서.
> - 세마포어의 `wait(P)` / `signal(V)` 연산이 **개념적으로** 어떤 일을 하는지 설명해봐라.
>     
>     (자원 개수 관점 + 프로세스를 block/wakeup하는 관점 두 가지로.)
>     
> - 모니터(Monitor)는 세마포어에 비해 어떤 점에서 **프로그래머에게 더 안전하고 편한 추상화**인가?
>     
>     (공유 자원 + 인터페이스 묶음, 자동 상호 배제, 조건 변수 관점에서 설명해봐라.)
>     
> - 모니터에서 사용하는 **조건 변수(condition variable)** 의 역할은 무엇이고,
>     
>     `wait()` / `signal()`은 각각 어떤 상황에서 호출되는지 생산자–소비자 예로 설명해봐라.
>     

---

## 동기화란?

여러 프로세스(또는 스레드)가 **동시에 실행**되면,

서로 **데이터를 주고받고, 같은 자원(파일, 변수, 장치)을 공유**하면서 협력하게 된다.

이때 아무 규칙 없이 “마구 동시에” 실행되면:

- 공유 데이터가 **엉망**이 되고
- 실행 순서가 꼬여서 **올바른 결과를 보장할 수 없게** 된다.

그래서 운영체제는 **동기화(synchronization)** 메커니즘을 제공한다:

> 여러 실행 흐름(프로세스/스레드)의 수행 시기와 자원 접근을 조율하는 것
> 

### 프로세스 / 스레드 동기화

동기화의 두 가지 핵심 목적:

1. **실행 순서 제어 (순서 동기화)**
    - “A가 끝난 뒤에 B가 실행되어야 한다” 같은 **수행 순서를 보장**하는 것
2. **상호 배제 (Mutual Exclusion)**
    - 동시에 접근하면 안 되는 자원(공유 변수, 파일 등)에
        
        **한 번에 하나의 실행 흐름만** 들어가게 하는 것
        

> 프로세스뿐 아니라 스레드도 동기화 대상이다.
> 
> 
> 즉, **실행 흐름을 가진 모든 것(프로세스, 스레드)** 이 동기화의 대상이다.
> 

### 실행 순서 제어 예시

동시에 실행되는 프로세스를 **올바른 순서**로 실행시키는 것.

예시:

- `Writer` 프로세스: 어떤 값을 `data.txt` 파일에 저장
- `Reader` 프로세스: `data.txt`에 저장된 값을 읽어옴

이때:

- `Reader`는 **반드시 Writer가 파일에 값을 쓴 뒤** 실행되어야 한다.
- 만약 순서 제어 없이 Reader가 먼저 실행되면?
    - 아직 아무것도 쓰지 않은 파일을 읽거나, **이전 값**을 읽을 수 있다.

→ 이런 상황에서 운영체제/프로그래머는

- “Writer가 **완료된 이후에만** Reader를 실행하게” 동기화를 걸어야 한다.
    
    → 이것이 **실행 순서 제어(synchronization for ordering)** 이다.
    

### 상호 배제 (Mutual Exclusion)

- **상호 배제(mutual exclusion)** 란:

> 동시에 접근하면 안 되는 공유 자원에
> 
> 
> **하나의 프로세스/스레드만 접근하도록** 보장하는 것
> 

대표적인 예: **생산자-소비자(Producer–Consumer) 문제**

- 공유 자원: **버퍼(buffer)**
    - 생산자(Producer): 버퍼에 데이터를 **집어넣는** 역할
    - 소비자(Consumer): 버퍼에서 데이터를 **꺼내는** 역할
- 버퍼의 상태를 나타내는 변수(예: `count`)가 있다고 하자.

문제:

- 생산자: `count++`
- 소비자: `count--`
- 둘이 동시에 실행되면, `count`를 읽고 쓰는 타이밍에 따라
    
    **실제 버퍼 상태와 다른 값**으로 남을 수 있다 → **레이스 컨디션**
    

→ 해결책:

- `count`와 버퍼를 조작하는 코드를 **임계 구역(critical section)** 으로 묶고,
    
    한 번에 **하나의 실행 흐름만** 임계 구역에 들어가게 해야 한다.
    
    (뮤텍스, 세마포어, 모니터 등 사용)
    

### 공유 자원과 임계 구역, 레이스 컨디션

- **공유 자원 (Shared Resource)**
    
    여러 프로세스/스레드가 **공동으로 이용하는 자원**
    
    예: 전역 변수, 파일, 디바이스(프린터, 디스크), 소켓 등
    
- **임계 구역 (Critical Section)**
    
    공유 자원에 접근하는 코드 중에서,
    
    **둘 이상이 동시에 실행되면 안 되는 코드 부분**
    

문제: **레이스 컨디션 (Race Condition)**

- 둘 이상의 실행 흐름이 **동시에 임계 구역을 실행**하면서
    
    **실행 순서에 따라 결과가 달라지는 상황**
    
- 레이스 컨디션이 발생하면,
    
    **데이터 일관성(consistency)** 이 깨지고, 결과를 예측할 수 없게 된다.
    

따라서:

> 상호 배제를 위한 동기화 =
> 
> 
> 두 개 이상의 프로세스/스레드가
> 
> **동시에 임계 구역에 들어가지 못하도록** 제어하는 것
> 

---

## 동기화 기법

이제 **구체적으로 어떻게** 동기화를 구현할까?

목표:

- 임계 구역에 **항상 하나만** 들어가게 하기 (상호 배제)
- 필요한 경우 **올바른 실행 순서**를 보장하기 (조건 동기화)

대표 기법:

- 뮤텍스 락 (Mutex Lock)
- 세마포어 (Semaphore)
- 모니터 (Monitor)

### 뮤텍스 락 (Mutex Lock)

뮤텍스 락은 가장 기본적인 **상호 배제 도구**이다.

비유: **옷가게 탈의실**

- 탈의실에 문이 하나, 자물쇠 하나
    - 자물쇠가 잠겨 있으면 → **누군가 사용 중**
    - 자물쇠가 열려 있으면 → **들어가서 잠그고 사용**

**개념**

- **전역 변수 `lock`**: 자물쇠 상태를 나타내는 플래그 (0: 열림, 1: 잠김)
- **`acquire()`**: 임계 구역에 **들어가기 전에** 호출
- **`release()`**: 임계 구역에서의 **작업이 끝난 뒤** 호출

간단한 개념적 모습:

```c
acquire() {
    while (lock == 1) {
        // 누가 쓰는 중 → 기다린다 (busy wait)
    }
    lock = 1;  // 내가 잠근다
}

release() {
    lock = 0;  // 사용 완료, 잠금 해제
}
```

- `acquire()`는 **임계 구역에 들어가기 전**에 호출되어:
    - 이미 잠겨 있으면 → **잠금이 풀릴 때까지 계속 확인**
    - 잠금이 없으면 → `lock = 1`로 바꾸고 진입
- `release()`는 **임계 구역을 빠져나올 때** 호출되어:
    - 다시 `lock = 0`으로 바꾸어 다른 실행 흐름이 사용할 수 있게 한다.

> lock이 잠겨 있는 동안 계속 확인하는 행위를
> 
> 
> **바쁜 대기(busy wait, spin)** 라고 한다.
> 
> → CPU를 소비하면서 기다리는 방식이다.
> 

실제 OS에서는:

- 짧은 임계 구역에는 **스핀락(spinlock)** 으로 쓸 수 있지만,
- 일반적인 경우 커널이 **잠든 스레드를 블록(block)시키고**,
    
    락이 풀릴 때 **깨우는(wakeup)** 방식으로 오버헤드를 줄인다.
    

### 세마포어 (Semaphore)

세마포어는 뮤텍스보다 **더 일반화된 동기화 도구**이다.

- 뮤텍스 락: “**한 번에 1개**만 들어와라”에 특화
- 세마포어: “**동시에 최대 N개까지** 들어와도 된다” 같은 조건도 표현 가능

**기본 개념**

- 전역 변수 `S`: **사용 가능한 자원의 개수** (정수)
- `wait(S)` / `P(S)` / `down(S)`:
    - “자원을 하나 쓰겠다”는 요청
- `signal(S)` / `V(S)` / `up(S)`:
    - “자원을 하나 다 썼다”는 알림

개념적인 busy-wait 버전:

```c
wait(S) {
    while (S <= 0) {
        // 자원이 없으므로 기다린다 (busy wait)
    }
    S--;
}

signal(S) {
    S++;
}
```

하지만 바쁜 대기는 비효율적이므로,

실제 OS에서는 다음처럼 구현한다:

- `S <= 0`이면:
    - **해당 프로세스를 blocked 상태로** (대기 큐에 넣고) 잠재운다.
- `signal(S)`에서:
    - 대기 큐에 있는 프로세스를 하나 꺼내서 **wakeup**시킨다.

**< 세마포어 종류 >**

- **카운팅 세마포어 (Counting semaphore)**
    - `S`를 0 이상 정수로 사용
    - 동시에 여러 개의 자원을 표현할 수 있음 (예: 버퍼 슬롯 10개)
- **이진 세마포어 (Binary semaphore)**
    - `S`가 0 또는 1만 가지는 경우
    - 사실상 **뮤텍스와 거의 동일한 역할**

### 모니터 (Monitor)

세마포어는 **강력하지만 사용이 번거롭고 실수하기 쉽다.**

- 임계 구역 앞뒤에 항상 `wait()` / `signal()`을 **직접** 넣어줘야 하고,
- 하나라도 빠뜨리거나 순서를 잘못 쓰면 **쉽게 버그**가 발생한다.

그래서 등장한 것이 **모니터(monitor)** 이다.

> 모니터 = 공유 자원 + 그 자원에 접근하는 인터페이스(함수들)를 하나로 묶고,
> 
> 
> 내부에서 **자동으로 상호 배제와 조건 동기화**를 제공하는 추상화
> 

**모니터의 특징**

- 공유 데이터는 **오직 모니터 내부 함수들(메서드)을 통해서만** 접근 가능
- 모니터 내부에는 **항상 하나의 프로세스/스레드만** 들어올 수 있음
    
    → 자동으로 **상호 배제 제공**
    
- 특정 조건(버퍼가 비었는지/찼는지 등)을 기다리고 깨우기 위해
    
    **조건 변수(condition variable)** 를 사용
    

**조건 변수와 연산**

조건 변수는 보통 다음 두 연산을 제공한다:

- `wait(cond)`
    - 특정 조건을 기다리는 연산
    - 호출한 스레드는:
        - **현재 모니터 락을 풀고(suspend)**
        - `cond` 큐에서 **잠든다(blocked)**
    - 나중에 `signal(cond)`가 호출되면 다시 깨워진다.
- `signal(cond)`
    - 해당 조건 변수를 기다리던 스레드 중 하나를 깨운다.

예를 들어, 생산자–소비자 문제를 모니터로 풀면:

- 모니터 안에:
    - 공유 버퍼 + `insert()` / `remove()` 함수
    - `notFull`, `notEmpty` 같은 조건 변수
- 생산자는:
    - 버퍼가 가득 찼으면 → `wait(notFull)`로 기다렸다가
    - 빈 공간이 생기면 `insert()` 수행 후 `signal(notEmpty)`
- 소비자는:
    - 버퍼가 비었으면 → `wait(notEmpty)`로 기다렸다가
    - 데이터가 생기면 `remove()` 수행 후 `signal(notFull)`

> Java의 synchronized 메서드/블록 + wait()/notify() 패턴이
> 
> 
> 모니터 개념을 언어 차원에서 구현한 대표적 예이다.
>
