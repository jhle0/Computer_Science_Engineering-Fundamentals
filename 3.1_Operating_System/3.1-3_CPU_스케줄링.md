# 3.1-3 CPU 스케줄링

> Active recall
> 
> - CPU 스케줄링의 **핵심 목적**은 무엇인가?
>     
>     (운영체제가 “지금 이 순간 어떤 프로세스에게 CPU를 줄지” 결정할 때, 어떤 성능 지표들을 최적화하려고 하는지 말해봐라.)
>     
> - **CPU-bound 프로세스**와 **I/O-bound 프로세스**의 차이를 설명하고,
>     
>     왜 이 특성을 고려해서 스케줄링해야 시스템 전체 성능이 좋아지는지 말해봐라.
>     
> - **선점형(preemptive)** 스케줄링과 **비선점형(non-preemptive)** 스케줄링의 차이를 설명하고,
>     
>     각 방식이 어떤 상황에서 유리한지 / 어떤 단점을 가지는지 큰 그림으로 비교해봐라.
>     
> - FCFS, SJF/SRTF, Round Robin, Priority 스케줄링을 떠올렸을 때,
>     
>     각각 **어떤 기준으로 다음 프로세스를 고르는 알고리즘인지** 한 줄씩 정리해봐라.
>     
>     (세부 수식 말고 “무엇을 우선하는가”에 초점을 맞춰서.)
>     
> - SJF/SRTF와 Priority 스케줄링에서 공통적으로 발생할 수 있는 **기아(starvation)** 문제는 어떤 상황에서 나타나고,
>     
>     이를 완화하기 위해 사용하는 **에이징(aging)** 의 아이디어를 설명해봐라.
>     
> - Multilevel Queue와 Multilevel Feedback Queue 스케줄링의 차이를 설명해봐라.
>     
>     (특히 **큐 사이 이동 가능 여부**와, 왜 MLFQ가 “현실적인 스케줄링 전략”으로 자주 쓰이는지 관점에서.)
>     

---

## CPU 스케줄링 개요

여러 프로세스가 동시에 존재하면 **모두 CPU를 쓰고 싶어 한다.**

하지만 CPU는 한 순간에 **한 프로세스만** 실행할 수 있다.

그래서 운영체제는 다음을 결정해야 한다.

> “지금 이 순간, 어떤 프로세스에게 CPU를 줄 것인가?”
> 
> 
> → 이 결정을 내리는 것이 **CPU 스케줄링**이다.
> 

### CPU 스케줄링의 목표

대표적인 성능 지표:

- **CPU 이용률(CPU Utilization)**: CPU를 가능한 한 **놀리지 않고** 바쁘게 쓰게 하기
- **처리량(Throughput)**: 단위 시간당 **완료되는 프로세스 수**
- **총 반환 시간(Turnaround time)**: 프로세스가 **도착해서 종료될 때까지의 전체 시간**
- **대기 시간(Waiting time)**: 프로세스가 **준비 큐에서만 기다린 총 시간**
- **응답 시간(Response time)**: **첫 응답이 나올 때까지의 시간**
    - 특히 **대화형(Interactive) 시스템**에서 중요

→ 스케줄링 알고리즘은 보통

**“CPU 이용률/처리량 ↑, 대기·응답 시간 ↓”** 를 목표로 설계된다.

### CPU-bound vs I/O-bound 프로세스

- **CPU-bound job**
    - 대부분의 시간을 **CPU 연산**에 사용
    - 계산 위주의 프로그램, 배치 작업 등
- **I/O-bound job**
    - CPU는 잠깐 쓰고, **대부분 시간을 I/O 대기**에 사용
    - 사용자 입력 기다리기, 디스크/네트워크 I/O가 많은 프로그램 등

효율적인 시스템을 위해서는:

> I/O-bound 프로세스에 적절히 CPU를 먼저 줘서
> 
> 
> 빨리 I/O 요청을 던져놓고 다시 대기 상태로 보내고,
> 
> 그동안 CPU-bound 프로세스에게 CPU를 돌리는 것이 좋다.
> 

그래서 **프로세스의 성격과 중요도에 따라 우선순위(priority)를 부여**하여 스케줄링할 수 있다.

### 스케줄링 큐 (Scheduling Queues)

프로세스들은 각자 상황에 따라 **여러 개의 큐**에서 대기한다.

- **준비 큐(Ready Queue)**
    - “**지금 당장 CPU만 주면 실행할 준비 완료**” 상태의 프로세스들이 줄 서 있는 큐
- **대기 큐(Wait/Blocked Queue)**
    - 디스크 I/O, 키보드 입력, 네트워크 응답 등
        
        **특정 사건을 기다리며 blocked 상태에 있는 프로세스들**이 줄 서 있는 큐
        

운영체제는:

- 준비 큐에서 **스케줄링 알고리즘(FCFS, SJF, RR 등)** 과
    
    필요하면 **우선순위**를 고려해 다음에 실행할 프로세스를 선택한다.
    
- 대기 큐에 있던 프로세스는, I/O가 끝나면 다시 **준비 큐**로 이동한다.

### 선점형 / 비선점형 스케줄링

**문제 상황:**

A 프로세스가 CPU를 사용 중인데, **더 급한 프로세스 B**가 도착했다면?

### 비선점형 스케줄링 (Non-preemptive)

- 한 번 CPU를 잡은 프로세스는:
    - **자발적으로 CPU를 내놓을 때까지** (종료 or I/O 요청 등)
    - 다른 프로세스가 CPU를 빼앗을 수 없다.
- 구현은 단순하지만, 응답 시간이 길어질 수 있다.

### 선점형 스케줄링 (Preemptive)

- 운영체제가 **타이머 인터럽트** 등의 메커니즘을 이용해
    - *“이제 네 차례 끝, 다른 애한테 줘야지”* 하면서
        
        **현재 실행 중인 프로세스로부터 CPU를 강제로 빼앗을 수 있는 방식**이다.
        
- 장점:
    - 특정 프로세스의 **CPU 독점 방지**
    - 대화형 시스템에서 **응답 시간 개선**
- 단점:
    - **컨텍스트 스위칭이 자주 발생** → 오버헤드 증가

> 오늘날 대부분의 범용 운영체제(Windows, Linux, macOS 등)는
> 
> 
> **선점형 스케줄링**을 사용한다.
> 

---

## CPU 스케줄링 알고리즘

대표적인 알고리즘들을 간단히 정리한다.

### FCFS (First-Come, First-Served)

- **준비 큐에 도착한 순서대로** CPU를 할당하는 방식
- 비선점형 알고리즘이다.

**단점: 호위 효과(convoy effect)**

- CPU를 오래 쓰는 프로세스가 먼저 도착하면,
    - 뒤에 있는 **짧은 작업들**도 그 프로세스가 끝날 때까지 오래 기다려야 한다.
- → 전체 **평균 대기 시간**이 매우 나빠질 수 있다.

### SJF (Shortest Job First)

- **CPU 사용 시간이 가장 짧은 프로세스부터** 실행하는 방식
- 기본 SJF는 **비선점형**:
    - 한 번 CPU를 잡으면, 그 CPU 버스트를 끝까지 실행

**장점**

- 이론적으로 **평균 대기 시간을 최소화하는 최적 알고리즘**이다.
    
    (단, CPU 버스트 시간을 “정확히 알고 있다”는 가정하에)
    

**단점**

- CPU 사용 시간이 긴 프로세스는
    
    **짧은 프로세스들에 계속 밀려 기아(starvation)** 가 발생할 수 있다.
    
- 실제로는 CPU 버스트 시간을 정확히 알 수 없어서,
    - 과거의 실행 시간 정보를 바탕으로 **예측값**을 사용한다.

### SRT(SRTF) – Shortest Remaining Time First

- SJF의 **선점형 버전**이다.
- **현재 실행 중인 프로세스보다 남은 CPU 시간이 더 짧은 프로세스**가 도착하면,
    - CPU를 빼앗아 **남은 시간이 가장 짧은 프로세스**에게 CPU를 준다.

**특징**

- 항상 “남은 작업 시간이 가장 짧은 프로세스”를 선택하는 점에서
    - **SJF의 선점형 확장**으로 볼 수 있다.
- 마찬가지로 **기아(starvation)** 문제가 있을 수 있다.

### 라운드 로빈 (Round Robin, RR)

- **FCFS + 타임 슬라이스(time quantum)** 개념이 추가된 방식
- 준비 큐에 들어온 **순서대로** CPU를 할당하되,
    - 각 프로세스는 **정해진 시간만큼만(CPU 타임 슬라이스)** 사용하고,
    - 시간이 끝나면 다시 준비 큐의 **맨 뒤로** 돌아간다.

**타임 슬라이스(time quantum)가 중요**

- 너무 크면:
    - 거의 **FCFS와 차이가 없어짐** (응답 시간이 길어진다)
- 너무 작으면:
    - 컨텍스트 스위칭이 너무 자주 발생 → **오버헤드 증가**

> 대화형 시스템에서 공정성과 응답성을 모두 어느 정도 만족시키는
> 
> 
> 매우 널리 사용되는 기본 스케줄링 방식이다.
> 

### 우선순위 스케줄링 (Priority Scheduling)

- 각 프로세스에 **우선순위(priority)** 를 부여하고,
    - 우선순위가 높은 프로세스부터 실행하는 방식
- 선점형 / 비선점형 **둘 다 가능**하다.
    - 선점형: 더 높은 우선순위 프로세스가 오면 CPU를 빼앗음
    - 비선점형: 현재 프로세스가 끝날 때까지 기다렸다가 그 다음에 높은 우선순위를 실행

**문제: 기아(starvation)**

- 우선순위가 낮은 프로세스는
    
    **계속해서 실행이 뒤로 밀려 영원히 실행되지 못할 수 있다.**
    

**해결: 에이징(aging)**

- 오래 대기한 프로세스의 우선순위를 조금씩 증가시키는 방식
- 시간이 지날수록 **언젠가는 실행 기회를 보장**한다.

### 다단계 큐 스케줄링 (Multilevel Queue)

- 하나의 준비 큐만 쓰는 것이 아니라,
    
    **우선순위나 성격에 따라 여러 개의 준비 큐를 사용하는 방식**이다.
    
    - 예:
        - 상호작용(인터랙티브) 프로세스용 큐
        - 배치(batch) 작업 큐
        - 시스템 프로세스 큐 …

특징:

- **큐 간 우선순위**가 있다.
    - 우선순위가 높은 큐의 프로세스들이 **먼저 전부 처리**되고,
        
        그 뒤에 낮은 큐를 본다.
        
- 각 큐마다 **서로 다른 스케줄링 알고리즘**을 사용할 수 있다.
    - 예: 상위 큐는 RR, 하위 큐는 FCFS 등
- 큐 사이를 **이동하지 못하는** 모델이다. (한 번 배정되면 고정)

### 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue, MLFQ)

- Multilevel Queue와 비슷하지만,
    
    **프로세스가 큐 사이를 이동할 수 있다는 점이 핵심**이다.
    

일반적인 아이디어:

- 처음에는 **높은 우선순위 큐**에 넣고,
    - 타임 슬라이스를 다 쓰고도 작업을 끝내지 못하면
        
        → **점점 우선순위가 낮은 큐로 내려보낸다.**
        
    - CPU를 오래 쓰는 프로세스일수록 **낮은 우선순위 큐**로 가게 된다.
- 반대로, **너무 오래 기다린 프로세스**들은
    
    → 다시 **더 높은 우선순위 큐**로 올려서 기아를 방지한다.
    

장점:

- **인터랙티브(짧고 자주 CPU를 쓰는) 작업**은 높은 큐에서 빠르게 서비스 받고,
- **CPU-bound 작업**은 점점 아래 큐로 내려가면서
    
    시스템 전체 성능과 응답성을 밸런싱한다.
    
- 실제 운영체제에서 많이 사용하는 **현실적인 스케줄링 전략**이다
