# 3.1-7 파일 시스템

> Active recall
> 
> - **파일과 디렉터리는 각각 무엇인지**,
>     
>     OS 입장에서 “파일은 무엇으로 보고, 디렉터리는 무엇으로 보는지(특수한 파일 개념 포함)”를 설명해봐라.
>     
> - 파일의 **주요 메타데이터(속성)** 들을 가능한 한 많이 떠올려보고,
>     
>     각 속성이 **무슨 역할을 하는지** (권한, 시간 정보, 위치 등) 말해봐라.
>     
> - **절대 경로 vs 상대 경로**의 차이를,
>     
>     “루트 기준 / 현재 디렉터리 기준” 관점에서 예시와 함께 설명해봐라.
>     
> - 디스크/SSD를 쓰기 전에 해야 하는 두 단계인
>     
>     **파티셔닝(partitioning)** 과 **포매팅(formatting)** 이 각각 무엇을 의미하는 작업인지,
>     
>     “논리 디스크 나누기 vs 파일 시스템 구조 심기” 관점에서 설명해봐라.
>     
> - 파일을 디스크 블록에 배치하는 세 가지 방식인
>     
>     **연속 할당 / 연결 할당 / 색인 할당** 이
>     
>     각각 **어떤 구조로 블록을 배치하는지**,
>     
>     그리고 **장점/단점을 한 줄씩** 정리해봐라.
>     
>     (특히 외부 단편화, 임의 접근 속도, 오류 시 영향 관점에서.)
>     
> - **FAT 파일 시스템**이 “연결 할당”을 어떤 방식으로 개선한 구조인지,
>     
>     왜 각 블록 안이 아니라 **별도의 FAT 테이블**에 포인터를 모아 두는지 설명해봐라.
>     
> - **유닉스 파일 시스템(아이노드 기반)** 에서
>     
>     디렉터리 엔트리, i-node, 데이터 블록 사이의 관계를
>     
>     “이름 → i-node 번호 → 실제 메타데이터/블록 주소” 흐름으로 설명해봐라.
>     
> - **저널링 파일 시스템(journaling)** 이 왜 필요한지,
>     
>     “메타데이터 업데이트 도중 크래시” 상황을 가정하고,
>     
>     저널(로그)에 기록하고 커밋하는 방식이 **어떻게 파일 시스템 일관성 복구에 도움을 주는지** 말해봐라.
>     

---

## 파일과 디렉터리

파일과 디렉터리는 모두 **운영체제의 파일 시스템**이 관리하는 객체이다.

### 파일(File)

- 정의:
    - 하드 디스크, SSD 같은 **보조기억장치에 저장된 관련 정보의 집합**.
    - 의미 있고 관련 있는 정보를 모은 **논리적 단위**이다.
- OS 입장:
    - 파일은 단순한 바이트들의 **연속적인 시퀀스**(byte stream)으로 취급되는 경우가 많다.

**파일 속성(Attributes, Metadata)**

OS는 파일에 대해 다음과 같은 메타데이터를 관리한다.

- **유형(Type)**: 실행 파일, 디렉터리, 일반 파일, 장치 파일 등
- **크기(Size)**: 현재 파일 크기, 필요 시 최대 크기
- **보호(Protection)**: 어떤 사용자가 읽기/쓰기/실행 가능한지 (권한 비트, ACL 등)
- **생성 시간(Creation time)**
- **마지막 접근 시간(Last access time)**
- **마지막 수정 시간(Last modification time)**
- **소유자/그룹(Owner, Group)**
- **위치(Location)**: 디스크 상의 블록/아이노드 위치 등

**파일 유형 예시**

OS가 “파일 타입”을 엄격히 확장자로 구분하는 것은 아니지만, 관례적으로:

- 실행 파일: (확장자 없음), `exe`, `com`, `bin` …
- 목적 파일: `obj`, `o`
- 소스 코드 파일: `c`, `cpp`, `java`, `py` …
- 문서/워드 프로세서 파일: `txt`, `xml`, `rtf`, `doc`, `docx` …
- 라이브러리 파일: `lib`, `a`, `so`, `dll`
- 멀티미디어 파일: `mp3`, `wav`, `mpeg`, `mov`, `avi` …
- 압축/백업 파일: `zip`, `rar`, `7z`, `tar` …

**파일 연산(시스템 콜)**

응용 프로그램은 **직접 디스크를 건드리지 못한다.**

- 항상 **운영체제의 시스템 콜을 통해서만** 파일을 조작해야 한다.

대표적인 연산:

- 생성: `create`, `open(O_CREAT)`
- 삭제: `unlink`, `remove`
- 열기/닫기: `open`, `close`
- 읽기/쓰기: `read`, `write`
- 파일 위치 변경: `lseek`
- 속성 변경: `chmod`, `chown` 등

### 디렉터리(directory)

디렉터리는 파일들을 **계층적으로 조직**하기 위한 구조이다.

- 보통 **트리 구조**(또는 DAG 구조)를 가진다.
- 최상위 루트 디렉터리(`/` 또는 드라이브 루트)가 있고,
    
    그 아래에 서브 디렉터리들이 계속 계층적으로 붙는 형태이다.
    

- **절대 경로(absolute path)**:
    - 루트 디렉터리부터 시작하는 **유일한 전체 경로**.
    - 예: `/home/user/project/main.c`
- **상대 경로(relative path)**:
    - **현재 작업 디렉터리**를 기준으로 한 경로.
    - 예: `src/main.c`, `../include/header.h`

### 디렉터리 = 특별한 파일

많은 OS에서 디렉터리는 **“특수한 형태의 파일”** 로 구현된다.

- 디렉터리 내부에는 다음과 같은 정보가 **테이블 형태**로 들어 있음:
    - `(파일/디렉터리 이름, 해당 객체를 가리키는 메타데이터 정보 혹은 i-node 번호)`
- 즉,
    - 디렉터리 **엔트리(entry)** 들의 모음이 디렉터리 파일의 내용이다.

---

## 파일 시스템 구조 개요

파일 시스템은 보조기억장치 위에:

- **파일과 디렉터리를 어떻게 배치하고**
- **어떻게 빠르게/안전하게 접근할지**

를 정의하는 **데이터 구조 + 알고리즘 집합**이다

디스크/SSD 같은 저장 장치를 OS에서 사용하기 위해서는 보통:

1. **파티셔닝(Partitioning)**
2. **포매팅(Formatting)**

두 단계를 거친다

**파티셔닝(Partitioning)**

- 하나의 물리 디스크를 **여러 개의 논리적 영역**으로 나누는 작업.
- 각 영역을 **파티션(partition)** 이라고 부른다.
- 예:
    - `/dev/sda` 디스크에
        - `/dev/sda1` → 루트 파일 시스템
        - `/dev/sda2` → 홈 디렉터리
        - `/dev/sda3` → 스왑 영역
- 파티셔닝은 “**칸막이를 설치해 독립된 논리 디스크를 만드는 작업**”이라고 보면 된다.

**포매팅(Formatting)**

- 파티션 위에 **특정 파일 시스템 구조를 초기화하는 과정**이다.
- “디스크를 깨끗이 지운다”는 의미보다는
    - **부트섹터(또는 슈퍼블록)**,
    - **i-node 테이블 / FAT / 디렉터리 구조 / free-space 관리 구조** 등을 기록해
    - “이 파티션을 어떤 규칙으로 파일/디렉터리를 저장할 것인지”를 결정하는 과정이다.

### 파일 할당 방법

디스크는 보통:

- 여러 개의 **섹터(sector)** 로 나뉘고,
- 파일 시스템은 이들을 묶어 **블록(block)** 단위로 관리한다.

파일의 내용을 디스크 블록에 어떻게 배치할지에 따라:

1. **연속 할당(Contiguous allocation)**
2. **불연속 할당(Noncontiguous allocation)**
    - 연결 할당(Linked allocation)
    - 색인 할당(Indexed allocation)

으로 나눌 수 있다.

### **연속 할당(contiguous allocation)**

- 가장 단순한 방식.
- 파일이 차지하는 블록들이 **물리적으로 연속된 블록들**에 할당된다.

디렉터리 엔트리:

- 파일 이름
- **첫 번째 블록 주소**
- **파일 길이(블록 수 또는 바이트 수)**

장점:

- **연속된 블록**이므로
    - 순차 접근(sequential access)과 임의 접근(random access) 모두 매우 빠르다.
    - 시작 위치 + offset으로 바로 계산 가능.

단점:

- **외부 단편화(external fragmentation)** 발생.
- 파일이 커졌을 때(append/grow) **뒤에 연속 블록이 없으면**:
    - 다른 위치로 통째로 옮기거나,
    - 복잡한 확장 구조를 넣어야 해서 관리가 어렵다.

### **연결 할당(linked allocation)**

연속 할당의 단점을 줄이기 위한 방식.

- 파일이 **연속된 블록에 있을 필요 없이**,
    
    아무 블록에나 배치해도 된다.
    
- 각 블록은 **다음 블록의 주소를 포함**하고,
    
    파일 전체가 **연결 리스트** 형태로 이어진다.
    

디렉터리 엔트리:

- 파일 이름
- **첫 번째 블록 주소**
- (보통 파일 크기 정보도 포함)

장점:

- 외부 단편화 문제 완화:
    - 아무 위치에 비어 있는 블록을 가져다 연결하면 되므로,
    - 연속 공간을 찾을 필요가 없다.
- 파일 크기가 늘어날 때:
    - 새 블록을 하나 할당하고, 이전 마지막 블록의 **다음 포인터**만 수정하면 된다.

단점:

- **임의 접근(random access)** 이 매우 비효율적:
    - n번째 블록을 읽으려면 **처음부터 차례로 포인터를 따라가야 한다.**
- 블록 중간이 깨지면:
    - 해당 지점 이후의 블록을 **모두 잃어버릴 수 있다.**
- 각 블록마다 “다음 블록 포인터”가 필요 → 오버헤드.

> 이 구조를 개선한 대표적인 시스템이 FAT(File Allocation Table) 이다.
> 
> 
> 블록 내부에 포인터를 두지 않고, **별도의 FAT 테이블에 포인터들을 모아 관리**한다.
> 

### 색인 할당(Indexed Allocation)

연결 할당의 “임의 접근 느리다” 문제를 해결하기 위한 방식.

- 각 파일마다 **색인 블록(index block)** 을 하나 둔다.
- 색인 블록 안에:
    - “이 파일이 사용하는 모든 데이터 블록 번호”를 **배열 형태**로 보관한다.

디렉터리 엔트리:

- 파일 이름
- **색인 블록 주소**

장점:

- n번째 블록 주소를 **색인 블록에서 한 번에 조회** 가능 → 임의 접근이 빠르다.
- 파일이 물리적으로 연속되지 않아도 됨 → 외부 단편화 완화.

단점:

- 작은 파일에도 **색인 블록 1개는 반드시 필요** → 메타데이터 오버헤드.
- 아주 큰 파일은:
    - 하나의 색인 블록만으로는 모든 블록 주소를 담기 어려움 → 다단계 인덱스, 직접/간접 블록 구조 필요.

> 이 아이디어를 확장한 것이 유닉스 파일 시스템(UNIX FS, ext 계열) 의 i-node 구조이다.
> 

---

## 대표적인 파일 시스템

### FAT 파일 시스템

- **연결 할당**을 테이블 기반으로 구현한 구조.
- 각 데이터 블록에 포인터를 넣는 대신:
    - 디스크 한 구역에 **File Allocation Table(FAT)** 이라는 **큰 배열**을 둔다.
- FAT의 각 엔트리:
    - “해당 블록의 **다음 블록 번호**” 또는
    - 파일 종료(EOC), 빈 블록, 예약 상태 등 표시.

장점:

- 연결 할당 특성을 유지하면서도,
    - FAT 테이블만 메모리에 올려두면 **연결 리스트 탐색이 빠름**.
- 구조가 단순해,
    - 플로피 디스크, USB 메모리, SD 카드 등의 **저용량/단순 기기**에서 널리 사용.

단점:

- 디스크 크기가 커질수록 FAT 테이블도 커짐.
    - 큰 디스크에서는 FAT를 메모리에 올리는 비용이 커지고 캐시 효율이 나빠질 수 있다.
- 파일 수/크기가 많아지면 성능 문제.

### 유닉스 파일 시스템(UNIX FS, i-node 기반)

**색인 할당 기반** 파일 시스템의 대표적인 예.

- 각 파일/디렉터리에 대해 **i-node(index-node)** 라는 구조체를 둔다.
- i-node에는:
    - 파일 종류(디렉터리/일반/장치 등)
    - 소유자, 권한, 크기, 시간 정보
    - **데이터 블록 주소들(직접/간접/이중 간접/삼중 간접 블록 포인터)**
        
        등이 들어 있다.
        

특징:

- **디렉터리 엔트리에는 “파일 이름 + i-node 번호”만 저장**:
    - 이름은 디렉터리에 있고,
    - 실제 메타데이터와 데이터 위치 정보는 i-node에 있다.
- 큰 파일을 위해:
    - i-node에는 일정 개수의 **직접 블록 포인터** +
        
        나머지는 **간접 블록 포인터(한 단계, 두 단계, 세 단계)** 를 사용.
        
    - 이를 통해 작은 파일도 효율적으로, 큰 파일도 확장 가능하게 저장.

### 저널링 파일 시스템(Journaling File System)

**저널링(journaling)** 은 파일 시스템의 **일관성을 높이기 위한 기술**이다.

문제 상황:

- 파일/디렉터리 메타데이터를 갱신하는 도중에
    - **전원 장애, 시스템 크래시**가 발생하면,
    - 디스크에 **부분적으로만 반영된 상태**가 될 수 있다.
    - → 파일 시스템이 **손상(일관성 깨짐)** 될 가능성.

아이디어:

> 실제 메타데이터를 업데이트하기 전에,
> 
> 
> **“어떤 변경을 할 것인지”를 로그(저널)에 먼저 기록**하고,
> 
> 변경이 성공적으로 완료되었음을 표시한 뒤 커밋하는 방식.
> 

동작 개념:

1. 파일 시스템 변경(예: 파일 생성, 삭제, 블록 재할당)을 위한 **트랜잭션(하나의 논리 작업 단위)** 을 만든다.
2. 이 트랜잭션 내용을 디스크의 **저널 영역(journal)** 에 순차적으로 기록한다.
3. 저널에 “커밋 완료”가 안전하게 기록된 뒤,
    - 실제 메타데이터/데이터 블록들을 본 위치에 반영한다.
4. 시스템 크래시 후 부팅 시:
    - 저널을 읽어보고,
    - 커밋 상태를 기준으로 **완료되지 않은 작업을 롤백/리플레이** 해서
    - 파일 시스템 일관성을 복구한다.

장점:

- 크래시 후 **fsck(파일 시스템 검사)** 를 전체 디스크에 대해 오래 돌리지 않고,
    - 저널만 빠르게 검사하여 **일관성 회복 시간이 크게 단축**된다.
- 메타데이터만 저널링하는 방식(메타데이터 저널링)과
    - 데이터까지 같이 저널링하는 방식(풀 저널링)으로 나뉜다.

대표적인 저널링 파일 시스템:

- Linux: **ext3, ext4, XFS, ReiserFS** 등
- Windows: **NTFS**
- 기타: JFS, ZFS(복구 방식은 다르지만 유사한 목표)
