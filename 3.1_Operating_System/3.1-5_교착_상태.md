# 3.1-5 교착 상태

> Active recall
> 
> - 교착 상태(deadlock)를 한 줄로 정의해봐라
> - 교착 상태 발생 4가지 조건을 설명해라
> - 교착 상태 해결 전략을 설명해라

---

## 교착 상태란?

여러 프로세스(또는 스레드)가 **서로가 가진 자원을 기다리면서**

아무도 앞으로 진행하지 못하는 상태를 **교착 상태(deadlock)** 라고 한다.

> 정의 한 줄
> 
> 
> **서로가 서로를 기다리느라, 더 이상 어떤 프로세스도 앞으로 나아가지 못하는 상태**이다.
> 

### 식사하는 철학자 문제 (Dining Philosophers Problem)

교착 상태를 설명하기 위한 고전적인 예이다.

- 둥근 식탁에 5명의 철학자가 앉아 있고,
    
    철학자 사이사이에 **포크(또는 젓가락)** 가 하나씩 놓여 있다. (총 5개)
    
- 각 철학자는
    - 배고프면 **왼쪽 포크를 집고**, 이어서 **오른쪽 포크를 집어** 식사를 한다.
    - 포크 두 개를 모두 집어야만 식사가 가능하다.

문제 상황:

1. 5명의 철학자가 **동시에 왼쪽 포크를 집는다.**
    
    → 각 포크는 양옆 철학자 한 명씩이 잡고 있음.
    
2. 이제 모두 오른쪽 포크를 집으려고 하지만,
    - 오른쪽 포크는 이미 오른쪽 철학자가 왼쪽 포크로 **잡고 있는 상태**이다.
3. 결국 **모두가 오른쪽 포크를 기다리며 무한히 대기**하게 되고,
    
    아무도 식사를 시작하지 못한다.
    

→ 이렇게 **일어나지 않을 사건(포크 반납)** 을 기다리며 전체 진행이 멈춰버리는 현상이

바로 **교착 상태(deadlock)** 이다.

## 교착 상태 발생 조건 (Coffman Conditions)

교착 상태가 발생하려면 **다음 네 가지 조건이 모두 성립**해야 한다고 알려져 있다.

1. **상호 배제 (Mutual Exclusion)**
2. **점유와 대기 (Hold and Wait)**
3. **비선점 (No Preemption)**
4. **원형 대기 (Circular Wait)**

- **상호 배제**
    - 어떤 자원은 **한 번에 하나의 프로세스만** 사용할 수 있다.
        
        예: 프린터, 포크, 특정 파일에 대한 쓰기 작업 등
        
    - 교착 상태가 발생한 근본적인 이유 중 하나는
        
        **자원이 나눠 쓸 수 없는(공유 불가능한) 성질**을 가졌기 때문이다.
        
    - → 상호 배제가 없으면(모두 동시에 써도 되면) 교착 상태도 없다.
- **점유와 대기**
    - 또 다른 이유는 자원을 **보유한 채 다른 자원을 기다렸기 때문**에 문제가 발생
- **비선점**
    - 이미 어떤 프로세스가 잡고 있는 자원을
        
        운영체제가 **강제로 뺏을 수 없는 상황**이다.
        
- **원형 대기**
    - 프로세스들이 **원 모양으로** 자원을 기다리는 상황이다.
    - 원형 대기가 없으면, 대기 그래프에서 **사이클이 존재하지 않으므로 교착 상태도 없다**고 볼 수 있다.

---

## 교착 상태 해결 방법

교착 상태 문제를 다루는 전략은 크게 세 가지로 나눌 수 있다.

1. **예방 (Deadlock Prevention)**
    
    → 애초에 **발생 조건 중 하나 이상을 깨뜨려서** 교착 상태가 일어나지 않게 하는 방법
    
2. **회피 (Deadlock Avoidance)**
    
    → 자원을 할당할 때마다 “이렇게 주면 나중에 교착 상태 위험이 있는지”를 **계속 확인**하며 할당하는 방법
    
3. **검출 후 회복 (Detection & Recovery)**
    
    → 일단 발생을 허용하고, **나중에 교착 상태를 탐지한 뒤** 강제로 풀어 주는 방법
    

### 교착 상태 예방

**네 가지 발생 조건 중 하나 이상이 항상 성립하지 않도록** 시스템을 설계하는 방법이다.

각 조건을 없애 보면 :

- 자원의 **상호 배제**를 없애 보면
    - 교착 상태를 없앨 수 는 있지만
    - 하지만 현실적으로
        - 프린터, 디스크 블록, 포크 같은 자원은
        
              **동시에 쓸 수 없기 때문에 상호 배제를 없애기 어렵다.**
        
- **점유와 대기**를 없애 보면
    - 프로세스는 **필요한 모든 자원을 한 번에** 요청해서 할당받도록 하고,
    - 자원을 다 얻지 못하면 **아무 것도 가지지 못한 상태로 대기**하게 하는 방법.
        - 이러면 자원의 활용률이 낮아진다
        - 또한 자원을 많이 사용하는 프로세스가 **초기에 자원을 확보하기 어려워 불리**해진다
- **비선점 조건**을 없애보면
    - 교착 상태가 발생하지 않겠지만
    - 모든 자원이 선점 가능한 것은 아니다(프린터 같이)
- 원형 대기 조건을 없애보면
    - 시스템 내 모든 자원 유형에 **번호(순서)를 부여**하고,
    - 프로세스가 자원을 요청할 때
        
        **항상 번호가 증가하는 순서대로만** 자원을 요청하도록 강제한다.
        
    - 모든 자원에 일관된 순서를 매기고
        
        그 순서를 **항상 지키도록 설계하는 것이 쉽지 않다.**
        

> 정리
> 
> 
> **예방 방식**은 “교착 상태가 원천적으로 발생하지 않는다”는 장점이 있지만,
> 
> 자원 활용률 저하, 사용성 저하 등 **부작용이 크기 때문에**
> 
> 실제 일반 목적 OS에서는 **순수 예방만 사용하는 경우는 드물다.**
> 

### 교착 상태 회피

**교착 상태가 발생할 수도 있는 상황(자원 그래프)에서**,

자원을 할당할 때마다

> “지금 이 프로세스에 자원을 이렇게 줘도,
> 
> 
> 나중에 **모든 프로세스가 언젠가는 끝까지 실행할 수 있는지**”를
> 
> 매번 검사하면서 **위험한 할당은 거절**하는 방식이다.
> 

- 안전 상태(safe state) - 교착 상태가 발생하지 않고 모든 프로세스가 정상적으로 자원을 할당 받고 종료될 수 있는 상태
- 불안전 상태(unsafe state) - 교착 상태가 발생할 수도 있는 상황
- 안전 순서열(safe sequence) - 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서

→ 교착 상태 **회피 방식**은:

> 자원을 할당하기 전에,
> 
> 
> “이 자원 할당 후에도 **어떤 안전 순서열이 존재하는지**”를 검사하고,
> 
> **항상 시스템을 안전 상태 안에 머물도록** 자원 할당을 조정하는 방식이다.
> 

### 교착 상태 검출 후 회복

이 방식은 **교착 상태 발생 자체를 막지 않는다.**

- 일단 **자원을 자유롭게 할당**하면서 시스템을 돌리다가,
- 주기적으로 **교착 상태인지 검사**(검출)하고,
- 교착 상태가 발견되면 **사후에 회복(recovery)** 하는 방법이다.

- **선점을 통한 회복**
    - 교착 상태가 해결될 때까지 한 프로세스 씩 자원을 몰아주는 방식이다
    - 자원을 **강제로 빼앗고** 한 프로세스에 할당하는 방식
- **프로세스 강제 종료를 통한 회복**
    - 교착 상태에 놓인 프로세스를 **모두 강제 종료**하거나
    - 교착 상태가 없어질 때까지 **한 프로세스씩 강제 종료**한다
