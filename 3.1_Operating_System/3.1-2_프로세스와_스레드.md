# 3.1-2 프로세스와 스레드

> Active recall
> 
> - **프로세스(Process)** 는 단순히 “실행 중인 프로그램”이 아니라, 어떤 것들의 묶음을 포함한 **실행 단위**라고 했지? 그 구성 요소를 큰 틀에서 설명해봐라.
> - **PCB / 컨텍스트 / 컨텍스트 스위칭**은 서로 어떤 관계에 있는가?
>     
>     (각각 무슨 역할을 하고, 왜 셋이 같이 묶어서 이해해야 하는지 말해봐라.)
>     
> - 프로세스의 **메모리 구조(코드 / 데이터 / BSS / 힙 / 스택)** 를 큰 그림으로 설명해보고,
>     
>     이 중 어떤 영역들이 **정적 영역**, 어떤 영역들이 **동적 영역**인지 나눠서 말해봐라.
>     
> - 프로세스 상태(`new, ready, running, blocked, terminated, suspended`)는 왜 이렇게 여러 단계로 나뉘어 있을까?
>     
>     운영체제가 **무엇을 관리하기 위해** 이런 상태 모델을 사용하는지 설명해봐라.
>     
> - **프로세스 계층 구조(부모/자식)** 와 `fork()`–`exec()` 패턴은 전체 시스템 관점에서 왜 중요한가?
>     
>     (운영체제가 프로세스를 어떻게 조직하고, 새 프로그램을 어떻게 실행시키는지 관점에서 설명해봐라.)
>     
> - **스레드(Thread)** 는 프로세스 안에서 어떤 역할을 하는가?
>     
>     “프로세스 vs 스레드”를 **자원 공유/분리** 관점에서 큰 틀로 비교해봐라.
>     
> - **멀티프로세스 vs 멀티스레드**를 비교할 때,
>     
>     왜 “**격리성과 안정성** vs **자원 효율성과 성능**”의 트레이드오프라고 부를 수 있는지 설명해봐라.
>     

---

## 프로세스 개요

### 프로세스(Process)란?

- 일반적으로 **“실행 중인 프로그램”** 이라고 부른다.
- 더 정확히는
    
    **프로그램 코드 + 그 코드를 실행하기 위해 할당된 자원(메모리, 열려 있는 파일, CPU 상태 등)** 을 모두 포함한 **실행 단위**이다.
    

- **포그라운드 프로세스**
    - 사용자가 직접 보는 화면(터미널, GUI 창 등)에서 실행되는 프로세스이다.
    - 예: 터미널에서 실행한 에디터, GUI 앱, 브라우저 등
- **백그라운드 프로세스**
    - 사용자가 직접 보지는 못하지만, **뒤에서 계속 돌면서 기능을 제공하는 프로세스**이다.
    - 이 중에서 사용자가 직접 상호작용하지 않고, 시스템 기능을 제공하는 것:
        - Unix 계열: **데몬(daemon)**
        - Windows: **서비스(service)**

### 프로세스 제어 블록 (PCB; Process Control Block)

- **PCB는 프로세스와 관련된 각종 정보를 저장하는 커널 내부의 자료구조**이다.
- 프로세스가 생성될 때 **커널 영역**에 생성되고,
    
    프로세스가 종료되면 함께 제거된다.
    

**PCB에 담기는 대표적인 정보**

- **프로세스 ID (PID)**: 프로세스를 식별하기 위한 고유 번호
- **레지스터 값**: CPU가 해당 프로세스를 실행하던 순간의 모든 레지스터 상태
- **프로세스 상태**: `new / ready / running / blocked / terminated / suspended` 등
- **CPU 스케줄링 정보**: 우선순위, 스케줄링 큐 위치 등
- **메모리 관리 정보**: 페이지 테이블 주소, 베이스/리미트 레지스터 등
- **열려 있는 파일 및 I/O 정보**: 파일 디스크립터, 할당된 I/O 장치 정보
- 기타: 부모/자식 프로세스 정보, 신호(signal) 처리 정보 등

> 즉, **PCB = “이 프로세스를 다시 실행시키는 데 필요한 모든 정보의 집합”** 이다.
> 

### 프로세스 Context

**Context** = 나중에 이 프로세스를 다시 실행하기 위해 **기억해 둬야 할 전체 상태**이다.

대표적으로:

- **하드웨어 컨텍스트 (CPU 수행 상태)**
    - Program Counter (PC)
    - 각종 레지스터 값
    - 상태 레지스터(플래그 레지스터) 등
- **프로세스의 주소 공간 (Logical address space)**
    - 코드(code) / 데이터(data, bss) / 힙(heap) / 스택(stack)
- **프로세스 관련 커널 자료 구조**
    - PCB
    - **커널 스택(kernel stack)**: 시스템 콜/인터럽트 처리 시 사용하는 스택

### 컨텍스트 스위칭(Context Switching)

- **컨텍스트 스위칭**: CPU가 **실행 중인 프로세스를 A → B로 바꾸는 과정**이다.

동작 흐름(직관):

1. 타이머 인터럽트, I/O 완료 인터럽트, 시스템 콜, 예외 등으로
    
    OS가 개입할 기회를 얻는다.
    
2. 현재 실행 중인 프로세스 A의 **컨텍스트(레지스터, PC 등)** 를 PCB에 저장한다.
3. 다음에 실행할 프로세스 B의 PCB에서 **컨텍스트를 읽어와 CPU에 복원**한다.
4. CPU는 B를 계속 실행한다.

> 컨텍스트 스위칭은 여러 프로세스가 아주 짧은 시간 단위로 번갈아 실행되는 메커니즘이다.
> 
> 
> 그래서 사용자 입장에서는 **여러 프로세스가 동시에 실행되는 것처럼** 보이게 된다.
> 

---

## 프로세스의 메모리 구조

프로세스가 생성되면,

- **커널 영역**에는 해당 프로세스의 PCB, 커널 스택 등의 정보가 생기고,
- **유저 영역**에는 프로세스의 주소 공간이 할당된다.

일반적인 구조(위→아래는 논리적 순서):

1. **코드 영역 (Text segment)**
2. **데이터 영역 (Data segment: 초기화된 전역/정적 변수)**
3. **BSS 영역 (초기화되지 않은 전역/정적 변수)**
4. **힙 영역 (Heap)**
5. **스택 영역 (Stack)**

### 코드 영역 (Text)

- 실행 가능한 **기계어 코드**가 저장된 영역이다.
- 보통 **읽기 전용(read-only)** 이며, 여러 프로세스가 같은 코드를 공유할 수 있다(예: 같은 프로그램 실행).

### 데이터 영역

- 프로그램이 실행되는 동안 **값이 유지되는 데이터**가 저장된다.
- 대표적으로 **전역 변수, 정적(static) 변수**가 여기에 위치한다.

### BSS 영역

- **초기값을 명시하지 않은 전역 변수 / 정적 변수**가 저장되는 영역이다.
- 실행 파일에는 “값 자체”가 저장되지 않고,
    
    **“여기에 0으로 초기화된 전역/정적 변수를 이만큼 만들어라”라는 정보만** 들어간다.
    
- 프로그램이 로드될 때 OS/런타임이 이 영역을 **0으로 초기화**한다.
- 데이터 영역과 BSS 영역을 분리하는 이유:
    - 초기값이 있는 데이터만 디스크에 저장하면 되므로,
        
        **실행 파일 크기를 줄이고 로딩을 효율적으로 하기 위해서**이다.
        

### 힙 영역 (Heap)

- 프로그램 실행 도중에 **동적으로 할당되는 메모리**가 저장되는 영역이다.
    - 예: `malloc`, `new` 등으로 얻는 메모리
- 개발자가 직접 할당/해제 관리:
    - 할당만 하고 해제하지 않으면 **메모리 누수(memory leak)** 발생

### 스택 영역 (Stack)

- 함수 호출 시 사용되는 **일시적인 데이터**를 저장한다.
    - 함수의 매개변수, 지역 변수, 복귀 주소 등
- 함수 호출/복귀에 따라 자동으로 늘고 줄어드는 구조이다.

> 코드/데이터 영역은 프로그램 시작 시 크기가 고정되므로 정적 할당 영역이다.
> 
> 
> 힙/스택 영역은 실행 중에 크기가 변할 수 있어 **동적 할당 영역**이라고 한다.
> 
> 보통 논리적으로 **힙은 낮은 주소에서 위로, 스택은 높은 주소에서 아래로** 자라면서 서로를 향해 커지는 구조로 설명한다.
> 

---

## 프로세스 상태와 계층 구조

### 프로세스 상태 (Process States)

프로세스는 실행되는 동안 여러 상태를 오간다.

**대표적인 상태들**

- **new**: 막 생성되어 메모리에 적재 중인 상태
- **ready**: 실행 준비는 되었지만, CPU를 아직 받지 못하고 **대기 중**인 상태
- **running**: CPU를 할당받아 실제로 명령어를 실행 중인 상태
- **blocked(waiting)**: I/O 완료 등 **어떤 사건을 기다리느라** CPU를 쓸 수 없는 상태
- **terminated**: 실행을 마치고 **종료된 상태**
- **suspended(stopped)**:
    - 외부 이유 (사용자 `stop`, OS 정책, 스왑 아웃 등)로 **일시 중단된 상태**
    - `suspended ready`, `suspended blocked` 등으로 더 세분화하기도 한다.

### 프로세스 계층 구조 (Process Hierarchy)

- 한 프로세스는 실행 도중 **시스템 콜을 통해 새로운 프로세스**를 생성할 수 있다.
- 이때:
    - 프로세스를 생성하는 쪽: **부모 프로세스(parent)**
    - 새로 만들어진 프로세스: **자식 프로세스(child)**
- 이런 식으로 프로세스들이 이어져서 **트리 구조**를 이루며, 이를 **프로세스 계층 구조**라고 한다.
    - Unix 계열에서는 최상위에 `init` 또는 `systemd` 같은 **루트 프로세스**가 존재한다.

### 프로세스 생성 기법: `fork`와 `exec` (Unix 관점)

- **`fork()`**
    - **현재 프로세스를 복사**하여 새로운 자식 프로세스를 만든다.
    - 부모와 자식은 같은 코드, 같은 주소 공간 구조를 가지지만,
        
        **PID가 다르고, 메모리는 논리적으로 분리**된다(실제로는 copy-on-write 최적화 등 사용).
        
- **`exec()`**
    - 현재 프로세스의 **코드/데이터/스택/힙 영역을 새로운 프로그램으로 갈아끼우는** 시스템 콜이다.
    - PID는 그대로 유지되지만, **실행 중인 프로그램이 바뀐다.**

일반적인 패턴:

1. 부모 프로세스가 `fork()`를 호출해 **자기 복사본(자식)** 을 만든다.
2. 자식 프로세스는 `exec()`를 호출해 **다른 프로그램을 실행**하도록 자신의 메모리 공간을 교체한다.

---

## 스레드(Thread)

### 스레드란?

- **스레드(thread)** 는 프로세스를 구성하는 **실행 흐름 단위(단일 흐름의 컨텍스트)** 이다.
- 전통적으로 “한 프로세스당 한 실행 흐름”만 있었다면(단일 스레드),
    
    스레드 개념이 도입되면서 **하나의 프로세스 안에서 여러 실행 흐름을 동시에 운용**할 수 있게 되었다.
    

> 리눅스에서는 프로세스와 스레드를 모두 “실행 문맥(context of execution)” 관점에서 보고,
> 
> 
> 내부적으로는 모두를 **태스크(task)** 라는 구조(`task_struct`)로 통일해 다루기도 한다.
> 

### 프로세스 vs 스레드

**프로세스마다 따로 가지는 것**

- 고유한 **주소 공간** (코드, 데이터, 힙)
- 열린 파일 테이블 (대부분 OS에서는 프로세스 단위로 공유하지만, 프로세스 간에는 독립)
- 각종 커널 자료 구조 (PCB 등)

**같은 프로세스 내 스레드들이 서로 공유하는 것**

- 코드 영역, 데이터 영역, 힙 영역
- 열린 파일, 소켓 등 대부분의 자원

**스레드마다 따로 가지는 것**

- 스레드 ID
- **Program Counter, 레지스터 값**
- **스택(stack)**

> 즉, 스레드는 **최소한의 실행 상태 정보(PC, 레지스터, 스택)** 만 따로 가지며,
> 
> 
> 나머지 자원은 같은 프로세스의 다른 스레드와 **공유**한다.
> 

### 멀티프로세스 vs 멀티스레드

- **멀티프로세스 (Multi-process)**
    - 여러 개의 **서로 다른 프로세스**를 동시에 실행하는 것
    - 각 프로세스는 기본적으로 **서로 독립된 주소 공간**을 사용한다.
- **멀티스레드 (Multi-thread)**
    - 하나의 프로세스 안에 **여러 스레드**를 두어 동시에 실행하는 것
    - 스레드들은 **동일한 주소 공간(코드/데이터/힙)** 을 공유한다.

**<장단점 비교>**

- **멀티프로세스**
    - 장점:
        - 프로세스 간 메모리 분리가 잘 되어 있어서 **안정성/격리성**이 좋다.
        - 한 프로세스가 죽어도 다른 프로세스에 영향이 덜하다.
    - 단점:
        - 프로세스 간 컨텍스트 스위칭 비용이 크다.
        - 데이터 공유가 어려워서, IPC(파이프, 소켓, 공유 메모리 등)를 써야 한다.
        - 같은 작업을 여러 프로세스로 돌리면 **중복되는 자원(코드/데이터)**이 많아 메모리 사용량이 늘어날 수 있다.
- **멀티스레드**
    - 장점:
        - 한 프로세스 안에서 스레드들이 코드/데이터/힙을 공유하므로
            
            **메모리를 더 효율적으로 사용**할 수 있다.
            
        - 스레드 간 문맥 전환이 프로세스 전환보다 **비교적 가볍다.**
        - I/O 대기 중인 스레드가 있어도 같은 프로세스 내 다른 스레드가 CPU를 사용할 수 있다.
    - 단점:
        - 공유 메모리 때문에 **race condition, deadlock** 같은 동시성 문제가 생기기 쉽다.
        - 잘못된 스레드 코드가 프로세스 전체 메모리를 망가뜨려, **프로세스 전체가 죽을 수 있다.**
