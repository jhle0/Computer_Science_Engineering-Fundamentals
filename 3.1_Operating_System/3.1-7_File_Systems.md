# 3.1-7 File Systems

> Active recall
> 
> - Explain **what files and directories are**,
>     
>     and from the OS point of view, how it treats “files” vs “directories” (including the idea that a directory is a special kind of file).
>     
> - Recall as many **file metadata (attributes)** as you can,
>     
>     and describe what each attribute is used for (permissions, timestamps, location, etc.).
>     
> - Explain the difference between **absolute path vs relative path**,
>     
>     with examples from the perspective of “root-based” vs “current-directory-based” paths.
>     
> - Before using a disk/SSD, you typically perform two steps:
>     
>     **partitioning** and **formatting**. Explain what each step does
>     
>     in terms of “splitting into logical disks” vs “laying down a file-system structure”.
>     
> - For the three block allocation methods
>     
>     **contiguous allocation / linked allocation / indexed allocation**,
>     
>     describe how each one arranges blocks on disk,
>     
>     and summarize the pros/cons in one line each
>     
>     (focusing on external fragmentation, random-access speed, and impact of errors).
>     
> - The **FAT file system** is built on top of linked allocation.
>     
>     Explain how it improves linked allocation,
>     
>     and why it stores pointers in a separate **FAT table** instead of inside each data block.
>     
> - In a **UNIX (inode-based) file system**,
>     
>     explain the relationship between directory entries, inodes, and data blocks
>     
>     in the flow “name → inode number → actual metadata / block addresses”.
>     
> - Explain why a **journaling file system** is needed.
>     
>     Assume a crash occurs in the middle of a metadata update,
>     
>     and describe how writing intents to a journal (log) and then committing
>     
>     helps restore file-system consistency.
>     

---

## Files and Directories

Files and directories are both **objects managed by the operating system’s file system**.

### File

- Definition:
    - A **collection of related information stored on secondary storage**, such as a hard disk or SSD.
    - A **logical unit** that groups meaningful and related data together.
- From the OS perspective:
    - A file is often treated simply as a **linear sequence of bytes** (byte stream).

### File Attributes (Metadata)

The OS keeps various metadata for each file:

- **Type**: executable file, directory, regular file, device file, etc.
- **Size**: current file size, and possibly maximum allowed size.
- **Protection**: which users can read/write/execute (permission bits, ACLs, etc.).
- **Creation time**
- **Last access time**
- **Last modification time**
- **Owner / group**
- **Location**: where the file’s data or inode resides on disk (blocks, inode number, etc.).

### Typical File Types (by convention)

The OS does not strictly rely on extensions, but by convention:

- Executable files: no extension, `exe`, `com`, `bin`, …
- Object files: `obj`, `o`
- Source code: `c`, `cpp`, `java`, `py`, …
- Documents: `txt`, `xml`, `rtf`, `doc`, `docx`, …
- Libraries: `lib`, `a`, `so`, `dll`
- Multimedia: `mp3`, `wav`, `mpeg`, `mov`, `avi`, …
- Archive/backup: `zip`, `rar`, `7z`, `tar`, …

### File Operations (System Calls)

Applications **cannot manipulate disks directly**.

- They must always go through the OS using **file-related system calls**.

Typical operations:

- Create: `create`, `open(O_CREAT)`
- Delete: `unlink`, `remove`
- Open / close: `open`, `close`
- Read / write: `read`, `write`
- Reposition file offset: `lseek`
- Change attributes: `chmod`, `chown`, etc.

### Directory

A directory is a structure used to **organize files hierarchically**.

- Usually forms a **tree** (sometimes a DAG).
- There is a **root directory** at the top (`/` on Unix-like systems, or drive root on Windows),
    
    and below that, subdirectories may contain other subdirectories and files.
    
- **Absolute path**:
    - A full, unique path starting from the root directory.
    - Example: `/home/user/project/main.c`
- **Relative path**:
    - A path interpreted **relative to the current working directory**.
    - Examples: `src/main.c`, `../include/header.h`

### Directory as a Special File

Many OSes implement directories as **special kinds of files**.

- Internally, a directory file contains a **table** of directory entries:
    - `(file/directory name, pointer to metadata or inode number)`
- So:
    - A directory is essentially a **list of entries** mapping names to inodes (or low-level identifiers).

---

## File-System Structure Overview

A file system defines how to:

- **Lay out files and directories on secondary storage**, and
- **Access them efficiently and safely**.

To use a disk/SSD with an OS, you typically perform:

1. **Partitioning**
2. **Formatting**

### Partitioning

- Splits a physical disk into **multiple logical regions**.
- Each region is called a **partition**.
- Example on a single disk `/dev/sda`:
    - `/dev/sda1` → root file system
    - `/dev/sda2` → home
    - `/dev/sda3` → swap
- Conceptually, partitioning is like **installing partitions/walls to create multiple logical disks** on top of one physical device.

### Formatting

- Initializes a partition with a **specific file-system structure**.
- Rather than just “erasing” the disk, it:
    - Writes a **boot sector or superblock**,
    - Creates **inode tables / FAT / directory structures / free-space maps**, etc.
- In other words:
    - It defines **how this partition will store and manage files and directories**.

---

## File Allocation Methods

Disks are divided into **sectors**, and file systems group sectors into **blocks** for management.

Depending on how file data is placed on blocks, we have:

1. **Contiguous allocation**
2. **Non-contiguous allocation**
    - Linked allocation
    - Indexed allocation

### Contiguous Allocation

- The simplest method.
- All blocks of a file are placed in **one continuous block range** on disk.

Directory entry typically contains:

- File name
- **Starting block address**
- **File length** (in blocks or bytes)

Pros:

- Very fast **sequential and random access**:
    - Given the start address and an offset, the target block can be computed directly.

Cons:

- Suffers from **external fragmentation**.
- When a file grows:
    - If there is no free space immediately following it,
    - The file may need to be moved or managed with extra complexity.

### Linked Allocation

Designed to reduce contiguous allocation issues.

- File blocks do not need to be contiguous; they can be **scattered** anywhere on disk.
- Each block contains a **pointer to the next block** in the file,
    
    forming a **linked list** of blocks.
    

Directory entry:

- File name
- **Address of the first block**
- Often file size

Pros:

- Greatly reduces external fragmentation:
    - Any free block can be used for the next part of the file.
- When the file grows:
    - Allocate a new block and update the previous last block’s “next” pointer.

Cons:

- **Very poor random-access performance**:
    - To access the n-th block, you must traverse from the first block step by step.
- If one block or pointer is corrupted:
    - All blocks after that point may become unreachable.
- Each block needs space for a pointer → overhead.

> The FAT (File Allocation Table) file system improves on this
> 
> 
> by moving these pointers into a separate table instead of storing them inside each data block.
> 

### Indexed Allocation

Solves the random-access problem of linked allocation.

- For each file, the file system allocates a dedicated **index block**.
- The index block contains **an array of all data-block numbers** used by the file.

Directory entry:

- File name
- **Address of the index block**

Pros:

- Random access is efficient:
    - The n-th block can be found by simply indexing into the index block.
- Blocks need not be contiguous → external fragmentation is reduced.

Cons:

- Even small files still require one index block → metadata overhead.
- Very large files may need:
    - Multi-level index blocks (single indirect, double indirect, etc.), increasing complexity.

> The inode-based UNIX file systems are built by extending this indexed-allocation idea.
> 

---

## Representative File Systems

### FAT File System

- A table-based implementation of **linked allocation**.
- Instead of storing the “next block pointer” inside each block, the system keeps:
    - A big table on disk called **FAT (File Allocation Table)**.

Each FAT entry:

- Stores the **index of the next block** in the file,
- Or a marker for:
    - End of chain (EOC),
    - Free block,
    - Reserved, etc.

Pros:

- Retains the flexibility of linked allocation.
- If the FAT table is cached in memory:
    - Following the linked list of blocks is relatively fast.

Cons:

- As disk size increases, the FAT table grows large:
    - Keeping it in memory can be expensive and may hurt cache efficiency.
- With many files and large capacities, FAT can suffer from performance issues.

Common use cases:

- Simple, low-capacity devices like **USB drives, SD cards, small flash storage**, etc.

### UNIX / inode-Based File Systems

A canonical example of **indexed allocation**.

- Each file/directory is represented by an **inode (index node)**.
- An inode stores:
    - File type (regular, directory, device, etc.),
    - Owner, group, permissions,
    - File size, timestamps,
    - **Pointers to data blocks**:
        - A fixed number of **direct block pointers**,
        - And one or more **indirect block pointers** (single, double, triple indirect).

Key relationships:

- **Directory entries**:
    - Store “file/directory name + inode number”.
- **Inode**:
    - Identified by its inode number; contains the metadata and block addresses.
- **Data blocks**:
    - Contain the actual file contents.

Result:

- Names live in directories,
    
    metadata and block locations live in inodes.
    

### Journaling File Systems

**Journaling** is used to improve **file-system consistency** and crash recovery.

Problem:

- If a crash or power loss occurs **during** metadata updates:
    - The on-disk structures may end up **half-updated**, leaving the file system inconsistent.

Idea:

> Before applying changes to the main file-system structures,
> 
> 
> write a description of those changes to a **journal (log)**,
> 
> then commit it, and only afterward apply them to the main metadata.
> 

Simplified workflow:

1. Group related file-system changes into a **transaction**.
2. Write this transaction to the **journal area** on disk.
3. Once safely written, mark the transaction as **committed**.
4. Apply the changes to the main metadata/data structures.

On reboot after a crash:

- The system reads the journal:
    - If it finds **committed but not fully applied** transactions,
        - It **replays** them to complete the changes.
    - If it finds **incomplete** transactions,
        - It can safely ignore or roll them back.

Benefits:

- Avoids scanning the entire disk with a long, full **fsck** after every crash.
- Greatly reduces recovery time while keeping the file system consistent.
- There are variants:
    - **Metadata-only journaling** (only metadata is journaled),
    - **Full data journaling** (both data and metadata are journaled).

Examples of journaling file systems:

- Linux: **ext3, ext4, XFS, ReiserFS**
- Windows: **NTFS**
- Others: JFS, ZFS (uses a different mechanism but with similar goals of consistency and recovery).
