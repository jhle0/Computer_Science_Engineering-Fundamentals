# 3.1-5 Deadlock

> Active recall
> 
> - Define a **deadlock** in one sentence.
> - Explain the **four necessary conditions** for deadlock.
> - Explain the main **strategies for handling deadlock**.

---

## What is a Deadlock?

When multiple processes (or threads) are **waiting for resources held by each other**,

so that **none of them can make further progress**, we say the system is in a **deadlock**.

> One-line definition
> 
> 
> **A state where every process is waiting on another, so no process can ever move forward.**
> 

---

### Dining Philosophers Problem

This is a classic example used to illustrate deadlock.

- Five philosophers sit around a circular table.
    
    Between each pair of philosophers, there is **one fork (or chopstick)**. (Total: 5)
    
- Each philosopher:
    - When hungry, first picks up the **left fork**, then the **right fork**,
        
        and can eat only when holding **both** forks.
        

Problem scenario:

1. All 5 philosophers **simultaneously pick up their left fork**.
    
    → Each fork is now held by one philosopher.
    
2. Now each philosopher tries to pick up their right fork, but
    - that fork is already being held as someone else’s left fork.
3. As a result, **everyone is waiting forever for the right fork**,
    
    and no one can start eating.
    

→ This situation, where everyone is **waiting for an event that will never happen**

(the fork being released), and the entire system is stuck,

is exactly a **deadlock**.

---

## Conditions for Deadlock (Coffman Conditions)

For a deadlock to occur, it is known that **all four** of the following conditions must hold:

1. **Mutual exclusion**
2. **Hold and wait**
3. **No preemption**
4. **Circular wait**
- **Mutual exclusion**
    - Some resources can be used by **only one process at a time**.
        
        Examples: printers, forks, exclusive write access to a file.
        
    - One root cause of deadlock is that
        
        the resource is **not shareable** (cannot be used concurrently).
        
    - → If mutual exclusion does *not* hold (everyone can share the resource),
        
        deadlock cannot occur.
        
- **Hold and wait**
    - A process is **holding at least one resource** and
        
        at the same time **waiting to acquire additional resources**.
        
- **No preemption**
    - Resources already allocated to a process **cannot be forcibly taken away**
        
        by the operating system.
        
    - The process must **release them voluntarily**.
- **Circular wait**
    - There exists a set of processes {P₁, P₂, …, Pₙ} such that
        
        P₁ is waiting for a resource held by P₂,
        
        P₂ is waiting for a resource held by P₃,
        
        …, and Pₙ is waiting for a resource held by P₁.
        
    - If there is **no circular wait**, the wait-for graph has **no cycle**,
        
        and thus a deadlock cannot occur.
        

---

## Strategies for Handling Deadlock

There are three main strategies for dealing with deadlocks:

1. **Prevention**
    
    → Design the system so that **at least one of the four conditions never holds**,
    
    and thus deadlock can never occur.
    
2. **Avoidance**
    
    → When allocating resources, **carefully check each request** to ensure that
    
    granting it will **not lead the system into a dangerous situation** where deadlock might occur.
    
3. **Detection & Recovery**
    
    → Allow deadlocks to happen, but **periodically detect** them and then
    
    **recover** by forcefully breaking the deadlock.
    

---

### Deadlock Prevention

Deadlock prevention means designing the system so that

**at least one of the four necessary conditions is always violated**.

Consider breaking each condition:

- **Mutual exclusion**
    - If we could make all resources **sharable**, deadlocks would disappear.
    - But in practice:
        - Many resources (printers, disk blocks, forks, etc.) **cannot be shared**,
            
            so removing mutual exclusion is usually impossible.
            
- **Hold and wait**
    - Strategy:
        - A process must **request all the resources it will ever need at once**.
        - If it cannot get all of them, it must wait having **none** of them.
    - Drawbacks:
        - **Low resource utilization**: resources may be allocated but idle.
        - Processes that need many resources may have **trouble starting at all**.
- **No preemption**
    - Strategy:
        - If a process is holding some resources and requests another one
            
            that is not immediately available,
            
            - then **take away (preempt) the resources** it currently holds and
                
                let it try again later.
                
    - Drawbacks:
        - Not all resources are practically preemptable (e.g., printers).
        - Implementation can be complex and costly.
- **Circular wait**
    - Strategy:
        - Impose a **total ordering** on all resource types (assign a unique number).
        - Require that each process requests resources **only in increasing order of their numbers**.
    - This prevents cycles in the wait-for graph, so **circular wait cannot occur**.
    - Drawback:
        - Assigning a consistent global order to all resource types
            
            and enforcing it everywhere can be **difficult in real systems**.
            

> Summary
> 
> 
> **Prevention** guarantees that deadlock will never occur,
> 
> but often causes **poor resource utilization and reduced flexibility**,
> 
> so pure prevention is rarely used in general-purpose OSes.
> 

---

### Deadlock Avoidance

Deadlock avoidance assumes that **deadlock is possible** in principle,

but tries to **avoid entering dangerous states**.

When allocating resources, the system checks:

> “If I grant this request now,
> 
> 
> can all processes still eventually complete at some point in the future?”
> 

Key concepts:

- **Safe state**
    - A state where there exists at least one **safe sequence** in which
        
        all processes can obtain the resources they need and **finish**,
        
        without ever entering deadlock.
        
- **Unsafe state**
    - A state that is **not guaranteed** to be safe.
    - It does **not** mean the system is already deadlocked,
        
        but deadlock **could** occur depending on future requests.
        
- **Safe sequence**
    - An ordering of processes (P₁, P₂, …, Pₙ) such that
        
        each process can obtain all the resources it needs, run to completion,
        
        and release its resources for the next process in the sequence.
        

Thus, deadlock **avoidance**:

> Before granting a resource request,
> 
> 
> the system checks whether **a safe sequence still exists after the allocation**,
> 
> and only grants the request if the system remains in a **safe state**.
> 

(Example algorithm: **Banker’s Algorithm**.)

---

### Deadlock Detection & Recovery

This approach **does not attempt to prevent or avoid** deadlock.

- The system **allocates resources freely** as requests come in.
- Periodically, it runs a **deadlock detection algorithm**.
- If a deadlock is detected, it performs **recovery** to break it.

Two main recovery methods:

- **Recovery by preemption**
    - Reclaim resources from some processes in the deadlock set,
        
        and give them to others until the deadlock cycle is broken.
        
    - This may involve **rolling back** some processes and later restarting them.
- **Recovery by process termination**
    - **Terminate all** processes involved in the deadlock, or
    - Terminate them **one by one** until the deadlock disappears.
    - The OS must choose which processes to kill based on some policy
        
        (priority, amount of work done, ease of restart, etc.).
