# 3.1-1 운영체제 개요

> Active recall
> 
> - 운영체제(OS)는 한 줄로 무엇을 하는 소프트웨어인가? (역할 2가지)
> - 운영체제가 관리하는 자원과, 그 위에 올려주는 추상화의 관계는?
> - 커널(Kernel)과 시스템 유틸리티(System Utilities)는 각각 어떤 역할인가?
> - 운영체제가 이중 모드(유저 모드 / 커널 모드)를 두는 핵심 이유는?
> - 시스템 콜(System Call)은 무엇이며, 왜 반드시 경유해야 하는가?
> - 인터럽트/트랩 + 컨텍스트 스위칭이 어떻게 “동시에 도는 느낌”을 만들까?

---

## 운영체제란

### 운영체제(Operating System, OS)

컴퓨터 하드웨어 바로 위에 설치되어 **사용자 및 모든 소프트웨어**와 **하드웨어**를 연결하는 프로그램이다.

> 한 줄 요약: OS = 컴퓨터 자원 관리자 + 추상화 제공자
> 
- **자원(Resource)**
    - CPU, 메모리, 디스크, 네트워크, 입출력 장치 등
- **추상화(Abstraction)**
    - **파일, 프로세스, 소켓** 같은 “사용하기 편한 가짜 인터페이스”를 제공하여
        
        하드웨어의 복잡한 동작을 숨기고 단순한 형태로 보여준다.
        

---

## 커널, 시스템 유틸리티

운영체제라고 부르는 것에는 보통

**커널 + 여러 시스템 유틸리티 프로그램** 이 함께 포함된다

### 커널(Kernel)

- **프로세스 관리, 메모리 관리, 파일 시스템, I/O, 네트워크 등 자원 관리 핵심 로직**이 들어 있는 부분이다.
- 항상 메모리에 상주하고, **커널 모드**에서만 실행된다.
- 하드웨어에 직접 접근할 수 있는 **특권 코드 영역**이다.

### 주변 시스템 유틸리티(System Utilities)

커널 위에서 실행되는 **일반 프로그램(유저 모드)**로, 사용자가 OS를 편하게 쓰도록 돕는 도구들이다.

- **사용자 인터페이스 + 편의 기능**을 담당한다.
- 예시
    - **셸(Shell), CLI, 터미널**: 명령어를 입력받아 프로그램 실행
    - **GUI 환경**: 윈도우/아이콘/마우스 등 사용자 그래픽 인터페이스
    - **파일 관리 유틸리티**: `ls`, `cp`, `mv`, 파일 탐색기(Explorer) 등
    - **시스템 관리 도구**: 작업 관리자, `top`, `ps`, `systemctl` 등
    - **패키지 관리자**: `apt`, `yum`, `pacman`, `brew` 등

---

## 이중 모드와 시스템 호출

운영체제는 **응용 프로그램이 자원에 직접 접근하지 못하게** 하고,

**항상 OS를 통해서만 접근**하도록 만들어 자원을 보호한다.

> 목적: OS와 다른 프로그램 보호 + 자원 중앙 통제 + 안정성/보안/멀티태스킹 보장
> 

### 이중 모드(Dual Mode)

CPU가 명령어를 실행하는 모드를 **유저 모드(User Mode)**와 **커널 모드(Kernel Mode)**로 구분한다.

(하드웨어가 **모드 비트(mode bit)**로 이 둘을 구분한다.)

- **유저 모드**
    - **위험한 명령(특권 명령)** 실행 불가
    - 디스크, 네트워크 카드, 타이머 등 **I/O 장치에 직접 접근 불가**
    - **OS가 허용한 메모리 범위** 안에서만 접근 가능 (MMU + 페이지 테이블로 보호)
- **커널 모드**
    - 특권 명령 실행 가능
    - 메모리 / I/O 장치에 직접 접근 가능
        
        → **“위험한 일”은 항상 커널 모드에서만 수행된다.**
        

> **특권 명령(Privileged Instructions)** 예시
> 
> - 페이지 테이블 변경
> - 타이머 설정
> - 디스크 I/O 직접 명령
> - 인터럽트 on/off 설정

### 시스템 콜(System Call)

사용자 프로그램이 **운영체제의 기능을 이용하기 위해 유저 모드에서 커널 모드로 전환을 요청하는 인터페이스**이다.

- 예: `read`, `write`, `open`, `fork`, `exec`, `socket` …
- 흐름:
    1. 유저 프로그램이 시스템 콜 호출 (소프트웨어 인터럽트/트랩 발생)
    2. CPU가 **유저 모드 → 커널 모드**로 전환
    3. 커널이 요청을 처리 (파일 열기, 메모리 할당, 소켓 생성 등)
    4. 작업이 끝나면 **커널 모드 → 유저 모드**로 돌아가 계속 실행

> 사용자는 기본적으로 유저 모드에서 응용 프로그램을 사용하다가,
> 
> 
> **운영체제 서비스가 필요할 때만 시스템 콜을 통해 커널 모드로 들어갔다가 다시 나오는 구조**이다.
> 

---

## 인터러트, 트랩, 컨텍스트 스위칭

### 인터럽트(Interrupt)

- 하드웨어/외부에서 **“OS야, 이거 처리해줘”**라고 CPU를 깨우는 신호
- 예:
    - 디스크 I/O 완료 인터럽트
    - 타이머 인터럽트(시간이 됐으니 스케줄링 필요함)

### 트랩(Trap)

- **프로그램 내부에서 발생하는 소프트웨어 인터럽트**
- 예:
    - **시스템 콜** (의도적으로 커널 호출)
    - **예외(Exception)**: 0으로 나누기, 잘못된 메모리 접근 등

### 컨텍스트 스위칭(Context Switch)

- CPU가 **프로세스 A → 프로세스 B**로 실행 대상을 바꿀 때,
- **레지스터, 프로그램 카운터, 상태 레지스터 등** CPU 상태를 저장하고 다시 복원하는 과정이다.
- 이 과정을 통해 여러 프로세스가 **CPU 하나를 번갈아 쓰면서 동시에 실행되는 것처럼 보이게** 된다.

---

## 운영체제 핵심 서비스

대표적으로 **프로세스 관리, 자원 관리(CPU/메모리/I/O), 파일 시스템 관리**를 제공한다.

### 프로세스 관리

- **프로세스(Process)**
    
    실행 중인 프로그램 + 필요한 자원(메모리, 파일, CPU 시간 등)을 합친 **실행 단위**이다.
    
- OS는 다양한 프로세스를 생성·삭제하고, 상태를 관리하고, CPU를 적절히 나눠주며 실행한다.

### 자원 접근 및 할당

- **CPU 스케줄링**
    - “어떤 프로세스에게 CPU를 줄까?”를 결정한다.
- **메모리 관리**
    - 각 프로세스를 **어느 주소에, 얼마나** 적재할지 결정한다.
    - 논리 주소 ↔ 물리 주소 매핑, 가상 메모리 관리 등 포함.
- **입출력(I/O) 관리**
    - 인터럽트와 **장치 드라이버**를 사용해 키보드, 디스크, 네트워크 카드 등과 데이터를 송수신한다.
    - I/O 요청 큐 관리, 버퍼링, 캐싱 등도 수행한다.

### 파일 시스템 관리

- **파일(File)**: 디스크 위의 데이터를 다루기 위한 **OS의 추상화**이다.
- OS는:
    - 파일 생성/삭제/열기/닫기
    - 디렉터리 구조 관리
    - 접근 권한 관리
        
        등을 담당한다.
        

---

## 운영체제 종류와 예시

대표적인 운영체제들:

- **Linux, Windows, macOS, Android, iOS**
    - **공통점**
        - 프로세스/스레드/파일/메모리 관리
        - 시스템 콜 인터페이스 제공
    - **차이점**
        - 커널 구조(모놀리식, 하이브리드 등), 라이선스, 지원 하드웨어, 사용자 환경, 기본 유틸리티 등
    - **Linux, Android**
        - **Linux 커널** 기반
        - Linux는 대표적인 **오픈 소스 운영체제**이다.
        - Android도 Linux 커널을 사용하고, 많은 부분이 오픈 소스로 공개되어 있다.
